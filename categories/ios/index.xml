<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ios on My New Hugo Site</title>
    <link>http://ytlvy.com/categories/ios/</link>
    <description>Recent content in Ios on My New Hugo Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 22 Aug 2015 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://ytlvy.com/categories/ios/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Big-endian &amp;&amp; Little-endian</title>
      <link>http://ytlvy.com/posts/2015-08-22/2015-08-22-big-endian-little-endian/</link>
      <pubDate>Sat, 22 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-08-22/2015-08-22-big-endian-little-endian/</guid>
      <description>&lt;h2 id=&#34;大端序与小端序&#34;&gt;大端序与小端序&lt;/h2&gt;

&lt;h3 id=&#34;何为大端序-小端序&#34;&gt;何为大端序，小端序？&lt;/h3&gt;

&lt;p&gt;简单点说，就是字节的存储顺序，如果数据都是单字节的，那怎么存储无所谓了，但是对于多字节数据，比如int，double等，就要考虑存储的顺序了。注意字节序是硬件层面的东西，对于软件来说通常是透明的。再说白一点，字节序通常只和你使用的处理器架构有关，而和编程语言无关，比如常见的Intel x86系列就是小端序。&lt;/p&gt;

&lt;h4 id=&#34;big-endian-大端序&#34;&gt;Big-endian（大端序）&lt;/h4&gt;

&lt;p&gt;数据的高位字节存放在地址的低端 低位字节存放在地址高端&lt;/p&gt;

&lt;h4 id=&#34;little-endian-小端序&#34;&gt;Little-endian（小端序）&lt;/h4&gt;

&lt;p&gt;数据的高位字节存放在地址的高端 低位字节存放在地址低端&lt;/p&gt;

&lt;h4 id=&#34;字节的高位与低位&#34;&gt;字节的高位与低位&lt;/h4&gt;

&lt;p&gt;举个例子，int a = 0x12345678 ; 那么左边12就是高位字节，右边的78就是低位字节，从左到右，由高到低，（注意，高低乃相对而言，比如56相对于78是高字节，相对于34是低字节）&lt;/p&gt;

&lt;p&gt;地址的高端与低端
0x00000001
0x00000002
0x00000003
0x00000004
从上倒下，由低到高，地址值小的为低端，地址值大的为高端。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C programming -- Array &amp; String</title>
      <link>http://ytlvy.com/posts/2015-08-22/2015-08-22-c-programming-array-string/</link>
      <pubDate>Sat, 22 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-08-22/2015-08-22-c-programming-array-string/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://www.cnblogs.com/kenshincui/p/3843505.html&#34;&gt;reference&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;c语言之数组和字符串&#34;&gt;C语言之数组和字符串&lt;/h2&gt;

&lt;h3 id=&#34;概览&#34;&gt;概览&lt;/h3&gt;

&lt;p&gt;数组在C语言中有着特殊的地位，它有很多特性，例如它的存储是连续的，数组的名称就是数组的地址等。而在C语言中是没有String类型的，那么如果要表示一个字符串，就必须使用字符数组。今天主要就介绍如下三个方面：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;一维数组&lt;/li&gt;
&lt;li&gt;多维数组&lt;/li&gt;
&lt;li&gt;字符串&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;一维数组&#34;&gt;一维数组&lt;/h3&gt;

&lt;p&gt;一维数组操作比较简单，但是需要注意，数组长度必须是固定的，长度不能使用变量进行初始化；如果声明的同时进行赋值则数组长度可以省略，编译器会自动计算数组长度；同时数组不能先声明再一次性赋值（当然可以对每个元素一一赋值）。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

int main(){
    int len = 2;
    //int a[len] = { 1, 2};//错误,不能使变量
    int a[2];//正确
    a[0] = 1;
    a[1] = 2;
    //a[2] = 3;//超过数组长度，但是编译器并不会检查，运行报错
    int b[&#39;a&#39;] = {1,2,3};//&#39;a&#39;=97，所以可以作为数组长度，但是后面的元素没有初始化，其值默认为0
    for (int i = 0; i &amp;lt; 97; ++i){
        printf(&amp;quot;b[%d]=%d\n&amp;quot;,i,b[i]);
    }
    int c[2 * 3];//2*3是固定值可以作为数组长度
    int d[] = { 1, 2, 3 };//如果初始化的同时赋值则数组长度可以省略，当前个数为3
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C programming -- Precompile</title>
      <link>http://ytlvy.com/posts/2015-08-22/2015-08-22-c-programming-precompile/</link>
      <pubDate>Sat, 22 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-08-22/2015-08-22-c-programming-precompile/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://www.cnblogs.com/kenshincui/p/3854242.html&#34;&gt;reference&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;c语言之预处理&#34;&gt;C语言之预处理&lt;/h2&gt;

&lt;h3 id=&#34;概述&#34;&gt;概述&lt;/h3&gt;

&lt;p&gt;大家都知道一个C程序的运行包括编译和链接两个阶段，其实在编译之前预处理器首先要进行预处理操作，将处理完产生的一个新的源文件进行编译。由于预处理指令是在编译之前就进行了，因此很多时候它要比在程序运行时进行操作效率高。在C语言中包括三类预处理指令，今天将一一介绍：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;宏定义&lt;/li&gt;
&lt;li&gt;条件编译&lt;/li&gt;
&lt;li&gt;文件包含&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;宏定义&#34;&gt;宏定义&lt;/h3&gt;

&lt;p&gt;对于程序中经常用到的一些常量或者简短的函数我们通常使用宏定义来处理，这样做的好处是对于程序中所有的配置我们可以统一在宏定义中进行管理，而且由于宏定义是在程序编译之前进行替换相比定义成全局变量或函数效率更高。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//
//  main.c
//  Pretreatment
//
//  Created by Kenshin Cui on 14-6-28.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//

#include &amp;lt;stdio.h&amp;gt;
#define PI 3.14 //宏定义一般大写
#define R 10
#define S 2*PI*R //在另一个宏里面引用了上面的宏

int main(int argc, const char * argv[]) {
    float r=10.5;
    double area=PI*r*r;
    printf(&amp;quot;area=%.2f\n&amp;quot;,area);
    
    double a=S;
    printf(&amp;quot;a=%.2f\n&amp;quot;,a);
    printf(&amp;quot;PI=3.14\n&amp;quot;);//注意输出结果不是3.14=3.14而是PI=3.14，字符串中的PI并不会被替换
#undef PI //强制终止宏定义，否则它的范围一直到文件结束
    int PI=3.1415926;
    double area2=PI*r*r;
    printf(&amp;quot;area2=%.2f\n&amp;quot;,area2);
    
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;宏定义实际的操作就是在预处理时进行对应替换，这个阶段不管语法是否正确，而且对于字符串中出现的宏名不会进行替换。宏定义的功能事实上是非常强大的，除了简单的常量替换还可以传入参数：&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C programming -- Struct</title>
      <link>http://ytlvy.com/posts/2015-08-22/2015-08-22-c-programming-struct/</link>
      <pubDate>Sat, 22 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-08-22/2015-08-22-c-programming-struct/</guid>
      <description>&lt;p&gt;@charset &amp;ldquo;UTF-8&amp;rdquo;;
/**
 *
 * @authors Your Name (you@example.org)
 * @date    2015-08-16 11:06:45
 * @version $Id$
 * Copyright &amp;copy; 2015年 Guo yanjie. All rights reserved.
 */&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.cnblogs.com/kenshincui/p/3856543.html&#34;&gt;reference&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;c语言之构造类型&#34;&gt;C语言之构造类型&lt;/h2&gt;

&lt;h3 id=&#34;概述&#34;&gt;概述&lt;/h3&gt;

&lt;p&gt;在第一节中我们就提到C语言的构造类型，分为：数组、结构体、枚举、共用体，当然前面数组的内容已经说了很多了，这一节将会重点说一下其他三种类型。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;结构体&lt;/li&gt;
&lt;li&gt;枚举&lt;/li&gt;
&lt;li&gt;共用体&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;结构体&#34;&gt;结构体&lt;/h3&gt;

&lt;p&gt;数组中存储的是一系列相同的数据类型，那么如果想让一个变量存储不同的数据类型就要使用结构体，结构体定义类似于C++、C#、Java等高级语言中类的定义，但事实上它们又有着很大的区别。结构体是一种类型，并非一个变量，只是这种类型可以由其他C语言基本类型共同组成。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//
//  main.c
//  ConstructedType
//
//  Created by Kenshin Cui on 14-7-18.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//

#include &amp;lt;stdio.h&amp;gt;

//结构体类型Date
struct Date{
    int year;
    int month;
    int day;
};

struct Person{
    char *name;
    int age;
    struct Date birthday;//一个结构体中使用了另一个结构体类型，结构体类型变量声明前必须加上struct关键字
    float height;
};

int main(int argc, const char * argv[]) {
    struct Person p={&amp;quot;Kenshin&amp;quot;,28,{1986,8,8},1.72};
    //定义结构体变量并初始化,不允许先定义再直接初始化，例如：struct Person p;p={&amp;quot;Kenshin&amp;quot;,28,{1986,8,8},1.72};是错误的，但是可以分别赋值，例如p.name=&amp;quot;Kenshin&amp;quot;
    
    printf(&amp;quot;name=%s,age=%d,birthday=%d-%d-%d,height=%.2f\n&amp;quot;,p.name,p.age,p.birthday.year,p.birthday.month,p.birthday.day,p.height); 
    //结果：name=Kenshin,age=28,birthday=1986-8-8,height=1.72，结构体的引用是通过&amp;quot;结构体变量.成员名称&amp;quot;(注意和结构体指针访问结构体成员变量区分，结构体指针使用p-&amp;gt;a的形式访问)
    
    printf(&amp;quot;len(Date)=%lu,len(Person)=%lu\n&amp;quot;,sizeof(struct Date),sizeof(struct Person)); 
    //结果：len(Date)=12,len(Person)=32
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C programming -- memory &amp; scope</title>
      <link>http://ytlvy.com/posts/2015-08-22/2015-08-22-c-programming-memory-scope/</link>
      <pubDate>Sat, 22 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-08-22/2015-08-22-c-programming-memory-scope/</guid>
      <description>&lt;p&gt;@charset &amp;ldquo;UTF-8&amp;rdquo;;
/**
 *
 * @authors yanjie Guo (ytlvy2008@gmail.com)
 * @date    2015-08-15 16:02:00
 * @version $Id$
 * Copyright &amp;copy; 2015年 Guo yanjie. All rights reserved.
 *
 */&lt;/p&gt;

&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;基本上每种语言都要讨论这个话题，C语言也不例外，因为只有你完全了解每个变量或函数存储方式、作用范围和销毁时间才可能正确的使用这门语言。今天将着重介绍C语言中变量作用范围、存储方式、生命周期、作用域和可访问性。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;变量作用范围&lt;/li&gt;
&lt;li&gt;存储方式&lt;/li&gt;
&lt;li&gt;可访问性&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;变量作用范围&#34;&gt;变量作用范围&lt;/h3&gt;

&lt;p&gt;在C语言中变量从作用范围包括全局变量和局部变量。全局变量在定义之后所有的函数中均可以使用，只要前面的代码修改了，那么后面的代码中再使用就是修改后的值；局部变量的作用范围一般在一个函数内部（通常在一对大括号{}内），外面的程序无法访问它，它却可以访问外面的变量。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//
//  main.c
//  ScopeAndLifeCycle
//
//  Created by Kenshin Cui on 14-7-12.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//

#include &amp;lt;stdio.h&amp;gt;

int a=1;
void changeValue(){
    a=2;
    printf(&amp;quot;a=%d\n&amp;quot;,a);
}
int main(int argc, const char * argv[]) {
    int b=1;
    changeValue(); //结果：a=2
    printf(&amp;quot;a=%d,b=%d\n&amp;quot;,a,b); //结果：a=2,b=1 ，因为changeValue修改了这个全局变量
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C programming -- pointer</title>
      <link>http://ytlvy.com/posts/2015-08-22/2015-08-22-c-programming-pointer/</link>
      <pubDate>Sat, 22 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-08-22/2015-08-22-c-programming-pointer/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://www.cnblogs.com/kenshincui/p/3848442.html&#34;&gt;reference&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;c语言之指针&#34;&gt;C语言之指针&lt;/h2&gt;

&lt;h3 id=&#34;概览&#34;&gt;概览&lt;/h3&gt;

&lt;p&gt;指针是C语言的精髓，但是很多初学者往往对于指针的概念并不深刻，以至于学完之后随着时间的推移越来越模糊，感觉指针难以掌握，本文通过简单的例子试图将指针解释清楚，今天的重点有几个方面：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;什么是指针&lt;/li&gt;
&lt;li&gt;数组和指针&lt;/li&gt;
&lt;li&gt;函数指针&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;什么是指针&#34;&gt;什么是指针&lt;/h3&gt;

&lt;p&gt;存放变量地址的变量我们称之为“指针变量”,简单的说变量p中存储的是变量a的地址,那么p就可以称为是指针变量,或者说p指向a。当我们访问a变量的时候其实是程序先根据a取得a对应的地址，再到这个地址对应的存储空间中拿到a的值，这种方式我们称之为“直接引用”；而当我们通过p取得a的时候首先要先根据p转换成p对应的存储地址，再根据这个地址到其对应的存储空间中拿到存储内容，它的内容其实就是a的地址，然后根据这个地址到对应的存储空间中取得对应的内容，这个内容就是a的值，这种通过p找到a对应地址再取值的方式成为“间接引用”。这里以表格形式列出a和p的存储以帮助大家理解上面说的内容：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://images.cnitblog.com/blog/62046/201407/161307139741921.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>iOS APP Icon Longpress shake</title>
      <link>http://ytlvy.com/posts/2015-08-11/2015-08-11-ios-app-icon-longpress-shake/</link>
      <pubDate>Tue, 11 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-08-11/2015-08-11-ios-app-icon-longpress-shake/</guid>
      <description>&lt;h2 id=&#34;ios-app图标长按抖动效果的实现-caanimation&#34;&gt;iOS APP图标长按抖动效果的实现（CAAnimation）&lt;/h2&gt;

&lt;p&gt;实现效果:当长按图标时，图标抖动，点击图标以外区域时停止抖动&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://img.blog.csdn.net/20150808181226925&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;工程下载：&lt;a href=&#34;https://github.com/Nongchaozhe/iconShakeDemo&#34;&gt;github工程下载&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;1) 视图代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@interface ViewController ()
{
    UIImageView *imageView;
}
@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];

    imageView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, 100, 100)];
    imageView.center = self.view.center;
    imageView.image = [UIImage imageNamed:@&amp;quot;icon1&amp;quot;];
    imageView.userInteractionEnabled = YES;
    [self.view addSubview:imageView];

    //添加长按手势
    UILongPressGestureRecognizer *recognize = [[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(longPress)];
    //长按响应时间
    recognize.minimumPressDuration = 1;
    [imageView addGestureRecognizer:recognize];
    // Do any additional setup after loading the view, typically from a nib.
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>iOS Crash Bugs</title>
      <link>http://ytlvy.com/posts/2015-08-11/2015-08-11-ios-crash-bugs/</link>
      <pubDate>Tue, 11 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-08-11/2015-08-11-ios-crash-bugs/</guid>
      <description>&lt;h2 id=&#34;crash-bug&#34;&gt;Crash Bug&lt;/h2&gt;

&lt;p&gt;1) ios7 下没有 &lt;code&gt;ContainString&lt;/code&gt; API&lt;/p&gt;

&lt;p&gt;2) NSDictionary &amp;amp; NSArray nil insert&lt;/p&gt;

&lt;p&gt;3) 数组越界 NSArray &lt;code&gt;out of bounds&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;4) &lt;code&gt;substringwithrange&lt;/code&gt; out of bounds&lt;/p&gt;

&lt;p&gt;5) &lt;code&gt;GPUImageView presentBufferForDisplay&lt;/code&gt; &amp;ndash; 内存泄露 或者 app 进入后台&lt;/p&gt;

&lt;p&gt;6) &lt;code&gt;locationOfTouch: inView:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (gestureRecognizer)numberOfTouches &amp;gt; 0){

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>iOS Music Background Play And Lock Screen Image</title>
      <link>http://ytlvy.com/posts/2015-08-11/2015-08-11-ios-music-background-play-and-lock-screen-image/</link>
      <pubDate>Tue, 11 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-08-11/2015-08-11-ios-music-background-play-and-lock-screen-image/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://blog.csdn.net/zsk_zane/article/details/47320621&#34;&gt;reference&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;ios-音乐后台播放及锁屏信息显示&#34;&gt;iOS 音乐后台播放及锁屏信息显示&lt;/h2&gt;

&lt;p&gt;实现音乐的后台播放，以及播放时，可以控制其暂停，下一首等操作，以及锁屏图片歌曲名等的显示
此实例需要真机调试，效果图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://img.blog.csdn.net/20150806175143383&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;工程下载：&lt;a href=&#34;https://github.com/Nongchaozhe/MusicRemoteControl&#34;&gt;github工程下载&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;实现步骤&#34;&gt;实现步骤：&lt;/h3&gt;

&lt;p&gt;1) 首先修改info.plist&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://img.blog.csdn.net/20150806174938474&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;2) 其次引入两个需要的框架&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#import &amp;lt;AVFoundation/AVFoundation.h&amp;gt;
#import &amp;lt;MediaPlayer/MediaPlayer.h&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3) 设置播放器及后台播放&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (void)viewDidLoad {
    [super viewDidLoad];
//    设置后台播放
    [[AVAudioSession sharedInstance] setCategory:AVAudioSessionCategoryPlayback error:nil];

//    设置播放器
    NSURL *url = [NSURL fileURLWithPath:[[NSBundle mainBundle] pathForResource:@&amp;quot;那些花儿&amp;quot; ofType:@&amp;quot;mp3&amp;quot;] ];
    _player = [[AVPlayer alloc] initWithURL:url];
    [_player play];
    _isPlayingNow = YES;

    //后台播放显示信息设置
    [self setPlayingInfo];
}

#pragma mark - 接收方法的设置
- (void)remoteControlReceivedWithEvent:(UIEvent *)event {
    if (event.type == UIEventTypeRemoteControl) {  //判断是否为远程控制
        switch (event.subtype) {
            case  UIEventSubtypeRemoteControlPlay:
                if (!_isPlayingNow) {
                    [_player play];
                }
                _isPlayingNow = !_isPlayingNow;
                break;
            case UIEventSubtypeRemoteControlPause:
                if (_isPlayingNow) {
                    [_player pause];
                }
                _isPlayingNow = !_isPlayingNow;
                break;
            case UIEventSubtypeRemoteControlNextTrack:
                NSLog(@&amp;quot;下一首&amp;quot;);
                break;
            case UIEventSubtypeRemoteControlPreviousTrack:
                NSLog(@&amp;quot;上一首 &amp;quot;);
                break;
            default:
                break;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>iOS NSNull Detect</title>
      <link>http://ytlvy.com/posts/2015-08-11/2015-08-11-ios-nsnull-detect/</link>
      <pubDate>Tue, 11 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-08-11/2015-08-11-ios-nsnull-detect/</guid>
      <description>Object-C中nil, NULL跟NSNull 相信不少开发者，都被NSNull坑过，最常见的是服务器返回的json里面，说好的字典、数组、数字，结果返回的是空值。这个时候，NSJSONSerialization 会自动把他们换成 NSNull。当我们再去用dict[@“hello”]的时候，就会出触发exception，导致程序崩溃。
最简单的做法 相信大家都知道，[NSNull null] 并不是一个工厂方法，而是一个单例模式，那么我们直接去判断赋值的这个指针是不是[NSNull null] 就好了。
那么问题来了，编译器会多了一个warning，很烦人。
在这篇文章里面介绍了各种做法：
- (void)someMethod { NSString *aString = @&amp;quot;loremipsum&amp;quot;; // This will complain: &amp;quot;Comparison of distinct pointer types (&#39;NSString *&#39; and &#39;NSNull *&#39;)&amp;quot; if (aString != [NSNull null]) { } // This works (at least for strings), but isEqual: does different things // for different classes, so it&#39;s not ideal if ([aString isEqual:[NSNull null]]) { } // If you cast it to the class you&#39;re comparing against // then you&#39;re good to go if (aString !</description>
    </item>
    
    <item>
      <title>Notes: The interesting things from WWDC, iOS 9, Swift 2</title>
      <link>http://ytlvy.com/posts/2015-08-08/2015-08-08-notes-the-interesting-things-from-wwdc-ios-9-swift-2/</link>
      <pubDate>Sat, 08 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-08-08/2015-08-08-notes-the-interesting-things-from-wwdc-ios-9-swift-2/</guid>
      <description>WWDC中那些令人感兴趣的事物:iOS 9, Swift 2   原文链接 : Notes: The interesting things from WWDC, iOS 9, Swift 2 原文作者: Rounak Jain 译文出自: 开发技术前线http://www.devtf.cn/ 译者 : Lollypo 校对者:Mr.Simple 状态 : 完成   今天WWDC上的Keynote非常棒,即便到目前为止还未结束.在开发者方面,已经有大量的新事物出现,其中包括有Swift 2, iOS 9, CloudKit等等.
这里是我在浏览发布日志,API差异,新特性等内容时记录的笔记
 你不需要加入$99的开发者计划就可以在真机上调试应用程序.此外,Mac与iOS开发者计划合并,可以节省一半支出:  Interface Builder支持实时预览模糊与透明效果  Objective-C支持泛型,这意味着集合对象,如数组,字典可以像Swift一样指定类型  新的名为 UIStackViewUI类,是Mac中NSStackView的一种实现.
 CloudKit现在也可以在Web中使用
 开放 CASpringAnimation!  应用程序现在可以作为拓展插入到Safari中,听起来有点像广告拦截器.此外,应用程序可以在Safari的共享链接填充内容
 开发者现在可以使用 SFSafariViewController, 这可以共享Safari中中cookies, 自动填充以及其他Safari中的特性.
 UIPickerView 可转换为任意尺寸,而不必再使用那些丑陋的转换技巧.
 iOS应用程序可在发出提醒展示一段文本域,此前仅限于Messages使用.
 通讯录可通过面向对象的API来访问,而不是之前的C
 电话API在低版本设备上不支持,这也许会导致编译时错误.现在有新的判断条件来决定是否执行代码,这可以有效避免使用新的API导致的应用程序崩溃:  UICollectionView 新添加了许多方法来支持交互式移动</description>
    </item>
    
    <item>
      <title>iOS Autolayout Practices</title>
      <link>http://ytlvy.com/posts/2015-08-08/2015-08-08-ios-autolayout-practices/</link>
      <pubDate>Sat, 08 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-08-08/2015-08-08-ios-autolayout-practices/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://blog.cnbluebox.com/blog/2015/02/02/autolayout2/&#34;&gt;reference&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;autolayout小结&#34;&gt;Autolayout小结&lt;/h2&gt;

&lt;h3 id=&#34;如何自动适应cell的高度&#34;&gt;如何自动适应cell的高度&lt;/h3&gt;

&lt;p&gt;在IOS的布局中，计算和适应cell的高度是个经典的问题, 在frame时代，我们都知道用&lt;code&gt;sizeWithFont:&lt;/code&gt; 先计算出文字的高度，然后通过计算得出cell的高度，然后赋予&lt;code&gt;heightForRow:&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;那在Autolayout时代如何计算cell的高度呢？因为sizeWithFont:方法已经不太实用了。其实Autolayout不但更简单，还可以不用写过多的计算代码达到自适应高度。&lt;/p&gt;

&lt;p&gt;理论上是可以通过已知的完整的Constraints和view的属性来计算高度的，我们可以通过&lt;code&gt;systemLayoutSizeFittingSize:&lt;/code&gt;方法来获取计算出来cell的size，我们知道cell的高度需要在tableView的代理方法&lt;code&gt;tableView:heightForRowAtIndexPath:&lt;/code&gt;中实现的，那么我们考虑从以下两点来做：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;通过创建一个额外的cell专门用来计算其高度&lt;/li&gt;
&lt;li&gt;因为计算需要布局，所以尽量让其只计算一次，计算完可以将高度保存起来&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>iOS Background Modes Tutorial</title>
      <link>http://ytlvy.com/posts/2015-08-08/2015-08-08-ios-background-modes-tutorial/</link>
      <pubDate>Sat, 08 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-08-08/2015-08-08-ios-background-modes-tutorial/</guid>
      <description>&lt;h1 id=&#34;ios后台模式开发指南&#34;&gt;iOS后台模式开发指南&lt;/h1&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;原文链接 : &lt;a href=&#34;http://www.raywenderlich.com/92428/background-modes-ios-swift-tutorial&#34;&gt;Background Modes Tutorial: Getting Started&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;原文作者 : &lt;a href=&#34;http://www.raywenderlich.com/u/rayfix&#34;&gt; Ray Fix &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;译者 : &lt;a href=&#34;https://github.com/MollyMmm&#34;&gt;MollyMmm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;校对者:David Hu&lt;/li&gt;
&lt;li&gt;状态 :  已完成&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;更新说明:这个教程被Ray Fix更新为关于iOS和Swift的.原著作者为&lt;a href=&#34;http://www.raywenderlich.com/29948/backgrounding-for-ios&#34;&gt;Gustavo Ambrozio&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;自从古老的iOS4以来,当用户点击home建的时候,你可以使你的APP们在内存中处于suspended(挂起)状态.即使APP仍停留在内存中,它的所有操作是被暂停的直到用户再次运行它.&lt;/p&gt;

&lt;p&gt;当然这个规则中有例外情况.在特定的情况下,这个APP仍然可以在后台中执行某些操作.这个教程会教你在什么时候怎么去用最常用的一些后台操作.&lt;/p&gt;

&lt;p&gt;每一次iOS的发布都会在后台操作和细节上的放宽限制，以此提升用户体验和延长电池寿命.对于在iOS中实现&amp;rdquo;真正&amp;rdquo;的多任务来说,后台模式不是一个神奇的解决办法.当用户切换到其他的APP应用时,大多数的APP应用仍然会完全的暂停运行.你的应用只被允许在很特殊的情况下才能在后台中继续运行.例如,这些包括播放音频,获取位置更新,或者从服务器获取最新内容的情况.&lt;/p&gt;

&lt;p&gt;iOS7之前,APP应用在真正暂停之前会有连续10分钟的时间去完成它们当前的操作.随着NSURLSession的出现,有了一种更为优雅的方式去应对大量的网络切换.因此,对于可用的后台运行时间已经减少到只有几分钟,而且不再必须为连续的.&lt;/p&gt;

&lt;p&gt;这样的后台模式可能不适合你.但如果合适,请继续阅读!&lt;/p&gt;

&lt;p&gt;接下来的学习中,将会有几个几个后台模式提供给你.在本教程中你将建立一个关于简单标签应用的工程,来探索从连续播放视频到周期性的获取更新内容的四种常见模式.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>iOS Continuous Integration &amp; Deployment</title>
      <link>http://ytlvy.com/posts/2015-08-08/2015-08-08-ios-continuous-integration-deployment/</link>
      <pubDate>Sat, 08 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-08-08/2015-08-08-ios-continuous-integration-deployment/</guid>
      <description>&lt;h2 id=&#34;ios项目的持续集成与管理&#34;&gt;iOS项目的持续集成与管理&lt;/h2&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;原文链接 : &lt;a href=&#34;https://medium.com/ribot-labs/continuous-integration-deployment-for-ios-projects-7358b72ca2e9&#34;&gt;Continuous Integration &amp;amp; Deployment for iOS Projects&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;原文作者 : &lt;a href=&#34;https://medium.com/@matto1990&#34;&gt;Matt Oakes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.devtf.cn&#34;&gt;译文出自 :  开发技术前线 www.devtf.cn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;译者 : &lt;a href=&#34;https://github.com/samlaudev&#34;&gt;Sam Lau&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;校对者: &lt;a href=&#34;https://github.com/bboyfeiyu&#34;&gt;Mr.Simple&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;状态 :  校正完&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;当实现新功能时，如果忽略可维护性而引入&lt;a href=&#34;http://en.wikipedia.org/wiki/Technical_debt&#34;&gt;技术债务&lt;/a&gt;，那将会需要延迟解决它或导致增加维护成本。&lt;/p&gt;

&lt;p&gt;最近我们已经思考通过哪些方式来提高代码的质量：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;当代码的质量下降时，通过设置一些工具来马上提醒开发者&lt;/li&gt;
&lt;li&gt;文档化一些编码规范和思考在过去的几个项目中如何避免维护性差的问题&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;我将会简单地概括我们需要设置什么才能自动监控代码质量.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;#基础
我们选择一个持续集成工具&lt;a href=&#34;https://jenkins-ci.org/&#34;&gt;Jenkins&lt;/a&gt;，让它运行在一台放在我们工作室的Mac Mini。其实我不怎么喜欢Jenkins，但到目前为止，它是最稳定和最适合的工具来完成这些工作。&lt;/p&gt;

&lt;p&gt;我们已经通过&lt;a href=&#34;https://brew.sh/&#34;&gt;Homebrew&lt;/a&gt;和&lt;a href=&#34;https://github.com/sstephenson/rbenv&#34;&gt;rbenv&lt;/a&gt;来分别安装Jenkins和Ruby，而rbenv能够为我们提供一个最新和稳定的&lt;a href=&#34;https://rubygems.org/&#34;&gt;Ruby Gems&lt;/a&gt;环境。有个Homebrew和Ruby Gems两个包管理工具之后，我们就几乎能够安装所有我们需要的工具，但很少会破坏与原有OS X系统更新提供的Ruby。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>iOS Dispatch_async usages tips</title>
      <link>http://ytlvy.com/posts/2015-08-08/2015-08-08-ios-dispatch-async-usages-tips/</link>
      <pubDate>Sat, 08 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-08-08/2015-08-08-ios-dispatch-async-usages-tips/</guid>
      <description>reference
Dispatch_async异步的小妙用 GCD 对于cocoa和cocoa Touch的开发者来说已经是在熟悉不过了，相信有些基础的人都能说出一些特性。但是今天我们不是讲GCD的介绍和使用bulabulabula. 本文就介绍下使用dispatch_async的一个小妙用，且看下文分解。
我们都知道dispatch_async可以用来异步执行代码。你的第一反应的可能是后台、多线程 这样的字眼，但是异步执行不是就代表多线程，它只是代表代码的执行方式，知道这点可以做更多事情。
afterDelay 你是否做过这样的事情，在修改一个bug时，把方法延迟执行，like this:
//[self doSomething]; [self performSelector:@selector(doSomething) withObject:nil afterDelay:0.1f];  Let me guess, 你一定是发现doSomething方法中所依赖的数据或环境还达不到，立即执行的话，可能会有问题。所以你就让doSomething延迟一点时间执行，保证它需要的数据或环境已经处理完成，改完打包测试，bug看起来已经修复了。
这个问题从大多数场景来说的确已经修复了，但是在强迫症眼里，好像还是有些瑕疵，不是完美方案。
两个问题，你怎么能100%确保你需要的数据或环境能再0.1s内准备完成呢； 另一个是数据准备完成到doSomething执行中间可能会有一段空白时间，有时是我们不希望的。那如何替代这个方案呢，如果你得doSomething需要的数据和环境是在主线程执行的，那么方案很简单：
//[self doSomething]; dispatch_async(dispatch_get_main_queue(), ^{ [self doSomething]; });  你可能问了，我本来就在主线程执行任务，为什么还要往main_queue里面提交任务呢。巧妙的地方就在这，我们巧妙的把doSomething作为任务提交到主线程，它会等待主线程的任务一个个执行完成才执行，这样就可以巧妙的解决这个问题。
不过注意，不是所有场景都适合这个用法，就像上面描述的，你要确保doSomething的依赖条件实在主线程中执行的。</description>
    </item>
    
    <item>
      <title>iOS UITableviewCell Swipeable</title>
      <link>http://ytlvy.com/posts/2015-08-08/2015-08-08-ios-uitableviewcell-swipeable/</link>
      <pubDate>Sat, 08 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-08-08/2015-08-08-ios-uitableviewcell-swipeable/</guid>
      <description>&lt;h2 id=&#34;ios开发-可滑动的单元格&#34;&gt;&lt;code&gt;iOS开发-可滑动的单元格&lt;/code&gt;&lt;/h2&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;原文链接 : &lt;a href=&#34;https://medium.com/ios-os-x-development/swipeable-table-view-cells-in-ios-apps-472da0af1935&#34;&gt;Swipeable table view cells in iOS apps&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;译者 : &lt;a href=&#34;https://github.com/mrchenhao&#34;&gt;Harries Chen&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;校对者: &lt;a href=&#34;https://github.com/mrchenhao&#34;&gt;Mr.Simple&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;我在过去的一个月里致力于开发我的创业项目，其中有一个功能就是我想让用户通过左右滑动表格来显示更多的选项（就像系统自带的邮件程序现实更多和删除一样，在这篇文章中我将讨论一些关于这方面的方法，以及如何动手实现它）&lt;/p&gt;

&lt;p&gt;首先，让我们来看一下现有的解决方法。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;UITableViewRowAction (new in iOS 8)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这是最好的方法如果你只是希望加一些从左滑到右才会出现的按钮。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/CEWendel/SWTableViewCell&#34;&gt;SWTableViewCell&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这是一个功能很全的按钮库，支持左滑和右滑，同时也可以在iOS8以前的版本中使用&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/MortimerGoro/MGSwipeTableCell&#34;&gt;MGSwipeTableCell&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果你想要实现表格的左右滑动功能，你可以从上面的解决方按照找到你需要的。但是为什么我们还要自己来实现呢？就我而言，我需要MGSwipeTableCell的一些功能，但是有的功能它对我并没有用，如果你想要自己来实现它，或者仅仅只是想要知道它的原理，那么接下去看。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>iOS float trap</title>
      <link>http://ytlvy.com/posts/2015-08-08/2015-08-08-ios-float-trap/</link>
      <pubDate>Sat, 08 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-08-08/2015-08-08-ios-float-trap/</guid>
      <description> float陷阱以及在Objc中的注意 浮点数不准，这个貌似基本都知道。但是在开发中很多人没有对它的使用产生警觉。如果你在开发Cocoa应用，你可能使用过如下代码判断系统版本：
if ([[[UIDevice currentDevice] systemVersion] floatValue] &amp;gt;= 7.0) { //something support for ios7 }  这样一段代码也的确工作良好，但是注意了如果你把比较的数值改为7.1，那么很有可能就会出问题。
浮点数不准 这一篇博文从二进制的表示方面说明了为什么浮点数不准，讲的很好，感兴趣的可以学习学习，学习这些感觉还是很有用的，也可以帮助我们定位一些诡异的问题。 浮点数的二进制表示 在精确的比较中不要使用float 文章开头的系统版本的比较就是一个典型的例子，我们可以通过其他方法实现比较：
if ([[[UIDevice currentDevice] systemVersion] compare:@&amp;quot;7.1&amp;quot;] != NSOrderedAscending) { //something support for ios7 }  </description>
    </item>
    
    <item>
      <title>iOS shake in pull to refresh</title>
      <link>http://ytlvy.com/posts/2015-08-08/2015-08-08-ios-shake-in-pull-to-refresh/</link>
      <pubDate>Sat, 08 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-08-08/2015-08-08-ios-shake-in-pull-to-refresh/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://blog.cnbluebox.com/blog/2015/01/19/shake-in-pull-to-refresh/&#34;&gt;reference&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;你的下拉刷新是否-抖-了一下&#34;&gt;你的下拉刷新是否“抖”了一下&lt;/h2&gt;

&lt;p&gt;在进入IOS8之后，你有没有注意到老式的下拉刷新可能会抖一下， 在下拉松开后，scrollView即将回到“刷新中…”的状态过程中的时候。如果你又这个问题，那不妨跟随我来看看怎么解决这个问题。&lt;/p&gt;

&lt;h3 id=&#34;抖动的原因&#34;&gt;抖动的原因&lt;/h3&gt;

&lt;p&gt;我们先来看看在手松开之后我们对scrollView做了什么事情：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ScrollViewDidEndDragging&lt;/code&gt; =&amp;gt; &lt;code&gt;setContentInset:&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;为了保证在“Loading”的状态下，下拉刷新控件可以展示，我们对&lt;code&gt;contentInset&lt;/code&gt;做了修改，增加了&lt;code&gt;inset&lt;/code&gt;的&lt;code&gt;top&lt;/code&gt;. 那这样一步操作为什么会导致scrollView抖动一下呢。&lt;/p&gt;

&lt;p&gt;我在&lt;code&gt;scrollViewDidScroll:&lt;/code&gt;中打了个断点，来看看在&lt;code&gt;setContentInset:&lt;/code&gt;之后发生了什么事情。 我设置的&lt;code&gt;inset.top = 64&lt;/code&gt;; 结果发现scrollView的&lt;code&gt;contentOffset&lt;/code&gt;发生了这样的变化：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(0, -64) =&amp;gt; (0, -133) =&amp;gt; (0, -64)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由以上数据可以看出，contentOffset在这个过程中先被向下移动了一段，再回归正常。 猜测问题原因：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;下拉松开之后， scrollView本身的 bounce 效果 与 当前设置inset冲突了
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>iOS8 iCloud</title>
      <link>http://ytlvy.com/posts/2015-08-08/2015-08-08-ios8-icloud/</link>
      <pubDate>Sat, 08 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-08-08/2015-08-08-ios8-icloud/</guid>
      <description>&lt;h2 id=&#34;ios8使用icloud&#34;&gt;&lt;code&gt;iOS8使用icloud&lt;/code&gt;&lt;/h2&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;原文链接 : &lt;a href=&#34;http://www.appcoda.com/cloudkit-introduction-tutorial/&#34;&gt;Working with CloudKit in iOS 8&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;译文出自 &lt;a href=&#34;http://www.dectf.cn&#34;&gt;开发技术前线&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;译者 : &lt;a href=&#34;https://github.com/mrchenhao&#34;&gt;Harries Chen&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;对于开发者来说，如何用适当的方式来存储应用程序数据是一个比较重要的问题。 毫无疑问，任何应用都或多或少需要存储一些数据。对于一般的应用程序来说，被保存的数据各不相同，大部分时间都被存储在本地以便再次在相同的设备运行该应用程序。尽管这不是是唯一的选择。随着云服务的发展，一个应用程序也可以把数据存储在云端，既可以完全把数据存储在云端，也可以本地和远程都存储。&lt;/p&gt;

&lt;p&gt;有许多网络服务商提供云服务，通常会赠送一定的免费空间。其中之一就是苹果，也就是著名的云服务提供商iCloud。开发人员可以访问iCloud，把它作为一个存储方式。有多种方法可以从iCloud中存储和读取数据，但在本教程中，我们将专注于其中之一：CloudKitframework。
&lt;img src=&#34;http://img.blog.csdn.net/20150515220618400&#34; alt=&#34;这里写图片描述&#34; /&gt;&lt;/p&gt;

&lt;p&gt;当你处理结构化数据（不是单纯的文件和文档）并希望将其保存在网络上的，使用CloudKit会非常方便。通过CloudKit，可以很容易的做到其它数据库能做的事情，代替数据库、记录等等。事实上，一条CloudKit记录就是iOS中大家都知道的字典，当然CloudKit还可以处理其它不同的数据。通过本教程，我们会发现使用这个框架是有趣的，而不是特别困难。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>iOS Application Framework Think - Network</title>
      <link>http://ytlvy.com/posts/2015-08-05/2015-08-05-ios-application-framework-think-network/</link>
      <pubDate>Wed, 05 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-08-05/2015-08-05-ios-application-framework-think-network/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://blog.cnbluebox.com/blog/2015/05/07/architecture-ios-1/&#34;&gt;reference&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;ios应用架构思考一-网络层&#34;&gt;IOS应用架构思考一（网络层）&lt;/h2&gt;

&lt;p&gt;最近看到Casa Taloyum同学的关于IOS架构的文章，分享的概念和观点很值得一看，于是不禁心痒，也做些分享吧，我会从实际设计过程中需要思考的问题的角度着手来讲述，毕竟无论什么样的架构，什么样的设计都是要解决这些问题的。
今天就先讲讲网络层的需要思考的问题吧。&lt;/p&gt;

&lt;h3 id=&#34;requestoperation的设计&#34;&gt;requestOperation的设计&lt;/h3&gt;

&lt;p&gt;我们都知道在客户端发送请求是需要成本的，那么设计异步的请求就是首要的问题。我们知道Cocoa提供了非常丰富和易于使用的异步api, 有&lt;code&gt;NSOperationQueue&lt;/code&gt;, &lt;code&gt;dispatch queue&lt;/code&gt;, &lt;code&gt;NSThread&lt;/code&gt;等。那么如何选择呢，答案毫无疑问的必须是&lt;code&gt;NSOperation&lt;/code&gt;。 不信你去看ASIHTTPRequest和AFNetworking. 好像这个理由不够充分是吧，而且很多人就是使用了这些框架，而不清楚它们到底为何优秀，那我就列举下一些它们的优点吧&lt;/p&gt;

&lt;p&gt;首先举个反例吧：曾经有人问过我“为什么要用AFNetworking和ASI这样的框架呢，我直接dispatch到后台用类似dataWithURL:拉数据这样不是很简单？”。 那么这样的使用案例有2个很致命的缺陷：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;无法cancel这个请求&lt;/li&gt;
&lt;li&gt;占用了完整的一个线程&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>iOS Best Practices</title>
      <link>http://ytlvy.com/posts/2015-08-05/2015-08-05-ios-best-practices/</link>
      <pubDate>Wed, 05 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-08-05/2015-08-05-ios-best-practices/</guid>
      <description>&lt;h1 id=&#34;ios-best-practices&#34;&gt;iOS Best Practices&lt;/h1&gt;

&lt;p&gt;这里总结一下iOS最佳实践，主要参考Futurice developers的文章&lt;a href=&#34;https://github.com/futurice/ios-good-practices&#34;&gt;iOS Good Practices&lt;/a&gt;，同时加上了一些自己的理解&lt;/p&gt;

&lt;p&gt;##目录
* &lt;a href=&#34;#setup_project&#34;&gt;初始化项目&lt;/a&gt;
* &lt;a href=&#34;#iOS_architecture&#34;&gt;iOS架构&lt;/a&gt;
* &lt;a href=&#34;#api_design&#34;&gt;API设计&lt;/a&gt;
* &lt;a href=&#34;#high_quality_code&#34;&gt;高质量代码&lt;/a&gt;
* &lt;a href=&#34;#code_style&#34;&gt;编码规范&lt;/a&gt;
* &lt;a href=&#34;#iOS_open_source_lib&#34;&gt;iOS开源库&lt;/a&gt;
* &lt;a href=&#34;#iOS_basic_skills&#34;&gt;iOS基本技能&lt;/a&gt;
* &lt;a href=&#34;#build_automation&#34;&gt;自动化构建&lt;/a&gt;
* &lt;a href=&#34;#optimiaze_app&#34;&gt;优化App&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;b id=&#34;setup_project&#34;&gt;&lt;/b&gt;
##初始化项目
###UI采用Interface Builder还是手写代码
当开始一个iOS项目时，一个常见的问题就是编写所有的views是采用手写代码的方式还是使用Interface Builder的Storyboard或XIB文件。两种方式都可以实现相同UI效果，但几点需要考虑：&lt;/p&gt;

&lt;p&gt;####为什么使用代码？
* 当多人协作开发时，由于Storyboard复杂的XML结构，它更容易发生版本冲突，这比手写代码的方式更难合并代码。
* 手写代码更容易地结构化和重用views，因此使你的代码库保持&lt;a href=&#34;http://en.wikipedia.org/wiki/Don%27t_repeat_yourself&#34;&gt;DRY&lt;/a&gt;。
* 所有的信息都在同一个地方。在Interface Builder中，你必须通过点击所有inspectors才能找到你想要的东西。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Variable Argument Lists</title>
      <link>http://ytlvy.com/posts/2015-08-04/2015-08-04-variable-argument-lists/</link>
      <pubDate>Tue, 04 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-08-04/2015-08-04-variable-argument-lists/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://gracelancy.com/blog/2014/05/05/variable-argument-lists/&#34;&gt;转自&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;variable-argument-lists&#34;&gt;Variable Argument Lists&lt;/h2&gt;

&lt;h3 id=&#34;variable-argument-lists-使用方法&#34;&gt;Variable argument lists 使用方法&lt;/h3&gt;

&lt;p&gt;可变参数函数（&lt;code&gt;Variadic Function&lt;/code&gt;），即是指一个可以接受可变数量的参数的函数。在C语言中，对该特性的支持，即是通过可变参数列表（Variable Argument list）来实现的，其定义在stdarg.h头文件。(若使用C++则在cstdarg头文件)。&lt;/p&gt;

&lt;p&gt;以如下C代码为例说明，该函数接受可变数量的整数作为参数，求和：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int addemUp (int firstNum, ...) {
  // 1. 参数后面添加省略号...
    va_list args;  // 2. 创建一个va_list类型的变量
    int sum = firstNum;
    int number;
    va_start(args, firstNum); // 3. 初始化va_list，此时va_list指向firstNum之后的第一个参数
    while (1) {
        number = va_arg(args, int); // 4. 获取当前指向的参数的值，并移动到下一个参数
        sum += number;
        if (number == 0) {
          // 用0表示结束
            break;
        }
    }
    va_end(args); // 5. 清理
    return  sum;
}

// 调用
sum = addemUp(1,2,3,4,5,0);
// sum = 15
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;要创建一个可变参数函数，需要把一个省略号（…)放在函数的参数列表后面。&lt;/li&gt;
&lt;li&gt;接着需要声明一个一个&lt;code&gt;va_list&lt;/code&gt;类型的变量，这个&lt;code&gt;va_list&lt;/code&gt;类型的变量类似于一个指向参数的指针。&lt;/li&gt;
&lt;li&gt;接着我们调用&lt;code&gt;va_start()&lt;/code&gt;并传入函数的最后一个声明的参数的变量名，来使得&lt;code&gt;va_list&lt;/code&gt;变量指向第一个附加的参数。&lt;/li&gt;
&lt;li&gt;接着我们调用&lt;code&gt;va_arg()&lt;/code&gt;并传入我们期待的参数类型，程序就会返回与该类型匹配数量的字节（即参数的值），并且移动va_list指向下一个参数。之后不断的调用&lt;code&gt;va_arg()&lt;/code&gt;，获得更多的参数的值，直到完成整个参数处理的过程。&lt;/li&gt;
&lt;li&gt;最后调用&lt;code&gt;va_end()&lt;/code&gt;来进行清理。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;variable-argument-lists-的内部机制&#34;&gt;variable argument lists 的内部机制&lt;/h3&gt;

&lt;p&gt;如我们之前所说，当我们调用 &lt;code&gt;va_start()&lt;/code&gt; 并将 &lt;code&gt;va_list&lt;/code&gt; 和函数最后定义的参数传入时，实际上是将 &lt;code&gt;va_list&lt;/code&gt; 内在的一个指针指向函数调用栈 （&lt;code&gt;call stack&lt;/code&gt;）中参数所在的区域的一端，每一次我们调用&lt;code&gt;va_arg()&lt;/code&gt;，其都会根据提供的类型，返回当前指针所指向的地址开始对应的字节数的数据，即参数的值，并移动指针相应字节数的距离。我们传给&lt;code&gt;va_arg()&lt;/code&gt;的类型，即是其用来判定需要取得得数据的大小，以及指针需要移动的距离。如图描述了这个过程：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://gracelancy.com/assets/post/val0.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;事实上，这是一个很危险的事情，你总是需要提供正确的类型来让va_arg()正确执行，而且va_arg()并不知道何时停止，你需要提供一个标记或一个参数的总数来停止va_arg()继续执行。若你提供了不正确的类型，或者没有在该停止的时候停止，你将会获得不可预测的值，并且很有可能导致程序崩溃。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>dSYM parse tool</title>
      <link>http://ytlvy.com/posts/2015-08-04/2015-08-04-dsym-parse-tool/</link>
      <pubDate>Tue, 04 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-08-04/2015-08-04-dsym-parse-tool/</guid>
      <description>&lt;h2 id=&#34;dsym-文件&#34;&gt;dSYM 文件&lt;/h2&gt;

&lt;h3 id=&#34;什么是-dsym-文件&#34;&gt;什么是 dSYM 文件&lt;/h3&gt;

&lt;p&gt;Xcode编译项目后，我们会看到一个同名的 &lt;code&gt;dSYM&lt;/code&gt; &lt;code&gt;文件，dSYM&lt;/code&gt; 是保存 16 进制函数地址映射信息的中转文件，我们调试的 symbols 都会包含在这个文件中，并且每次编译项目的时候都会生成一个新的 dSYM 文件，位于 &lt;code&gt;/Users/&amp;lt;用户名&amp;gt;/Library/Developer/Xcode/Archives&lt;/code&gt; 目录下，对于每一个发布版本我们都很有必要保存对应的 &lt;code&gt;Archives&lt;/code&gt; 文件 ( AUTOMATICALLY SAVE THE DSYM FILES 这篇文章介绍了通过脚本每次编译后都自动保存 dSYM 文件)。&lt;/p&gt;

&lt;h3 id=&#34;dsym-文件有什么作用&#34;&gt;dSYM 文件有什么作用&lt;/h3&gt;

&lt;p&gt;当我们软件 release 模式打包或上线后，不会像我们在 Xcode 中那样直观的看到用崩溃的错误，这个时候我们就需要分析 crash report 文件了，iOS 设备中会有日志文件保存我们每个应用出错的函数内存地址，通过 Xcode 的 Organizer 可以将 iOS 设备中的 DeviceLog 导出成 crash 文件，这个时候我们就可以通过出错的函数地址去查询 dSYM 文件中程序对应的函数名和文件名。大前提是我们需要有软件版本对应的 dSYM 文件，这也是为什么我们很有必要保存每个发布版本的 Archives 文件了。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>iOS NSURLProtocal</title>
      <link>http://ytlvy.com/posts/2015-08-04/2015-08-04-ios-nsurlprotocal/</link>
      <pubDate>Tue, 04 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-08-04/2015-08-04-ios-nsurlprotocal/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://xiangwangfeng.com/2014/11/29/NSURLProtocol%E5%92%8CNSRunLoop%E7%9A%84%E9%82%A3%E4%BA%9B%E5%9D%91/&#34;&gt;转自&lt;/a&gt;
最近用AFNetworking替换掉了工程里的ASIHttpRequest，结果陆续碰到很多问题：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如何统一地添加全局的HTTP头(不仅仅是UA而已)&lt;/li&gt;
&lt;li&gt;如何优雅地进行流量统计&lt;/li&gt;
&lt;li&gt;对特定的地址进行CDN加速(URL到IP的替换)&lt;/li&gt;
&lt;li&gt;怎么实现HTTP的同步请求&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;前三个需求对于ASIHttpReqeust来说都不是问题，只需要在几个统一的点进行修改即可。而使用AFNetworking后就没有那么容易了：一方面AFNetworking中生成NSURLRequest的点比较多，并没有一个统一的路径。其次工程中会有部分直接使用NSURLConnecion的场景，无法统一。经cyzju提醒发现了NSURLProtocol这个大杀器，可惜对应的文档过于简略，唯一比较详细的介绍就只有RW的这篇教程而已，掉了很多坑，值得记上一笔。&lt;/p&gt;

&lt;h2 id=&#34;nsurlprotocol&#34;&gt;NSURLProtocol&lt;/h2&gt;

&lt;h3 id=&#34;概念&#34;&gt;概念&lt;/h3&gt;

&lt;p&gt;NSURLProtocol也是苹果众多黑魔法中的一种，使用它可以轻松地重定义整个URL Loading System。当你注册自定义NSURLProtocol后，就有机会对所有的请求进行统一的处理，基于这一点它可以让你
- 自定义请求和响应
- 提供自定义的全局缓存支持
- 重定向网络请求
- 提供HTTP Mocking (方便前期测试)
- 其他一些全局的网络请求修改需求&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>iOS Toll-Free Bridging</title>
      <link>http://ytlvy.com/posts/2015-08-04/2015-08-04-ios-toll-free-bridging/</link>
      <pubDate>Tue, 04 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-08-04/2015-08-04-ios-toll-free-bridging/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://gracelancy.com/blog/2014/04/21/toll-free-bridging/&#34;&gt;reference&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;toll-free-bridging&#34;&gt;Toll-Free Bridging&lt;/h2&gt;

&lt;h3 id=&#34;什么是-toll-free-bridging&#34;&gt;什么是 Toll-Free Bridging&lt;/h3&gt;

&lt;p&gt;有一些数据类型是能够在 &lt;code&gt;Core Foundation Framework&lt;/code&gt; 和 &lt;code&gt;Foundation Framework&lt;/code&gt; 之间交换使用的。这意味着，对于同一个数据类型，你既可以将其作为参数传入 &lt;code&gt;Core Foundation&lt;/code&gt;函数，也可以将其作为接收者对其发送 &lt;code&gt;Objective-C&lt;/code&gt; 消息（即调用ObjC类方法）。这种在 &lt;code&gt;Core Foundation 和 Foundation&lt;/code&gt; 之间交换使用数据类型的技术就叫 &lt;code&gt;Toll-Free Bridging&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;举例说明，&lt;code&gt;NSString&lt;/code&gt;和&lt;code&gt;CFStringRef&lt;/code&gt;即是一对可以相互转换的数据类型：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// ARC 环境下
// Bridging from ObjC to CF
NSString *hello = @&amp;quot;world&amp;quot;;
CFStringRef world = (__bridge CFStringRef)(hello);
NSLog(@&amp;quot;%ld&amp;quot;, CFStringGetLength(world));

// Bridging from CF to ObjC
CFStringRef hello = CFStringCreateWithCString(kCFAllocatorDefault, &amp;quot;hello&amp;quot;, kCFStringEncodingUTF8);
NSString *world = (__bridge NSString *)(hello);
NSLog(@&amp;quot;%ld&amp;quot;, world.length);
CFRelease(hello);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;大部分（但不是所有！）&lt;code&gt;Core Foundation&lt;/code&gt; 和 &lt;code&gt;Foundation&lt;/code&gt; 的数据类型可以使用这个技术相互转换，Apple 的文档里有一个列表（&lt;a href=&#34;https://developer.apple.com/library/ios/documentation/General/Conceptual/CocoaEncyclopedia/Toll-FreeBridgin/Toll-FreeBridgin.html&#34;&gt;传送门&lt;/a&gt;），列出了支持这项技术的数据类型。
MRC 下的 &lt;code&gt;Toll-Free Bridging&lt;/code&gt; 因为不涉及内存管理的转移，可以直接相互 &lt;code&gt;bridge&lt;/code&gt; 而不必使用类似&lt;code&gt;__bridge&lt;/code&gt;修饰字，我们之后再讨论这个问题。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>iOS attribute objc_designated_initializer</title>
      <link>http://ytlvy.com/posts/2015-08-04/2015-08-04-ios-attribute-objc-designated-initializer/</link>
      <pubDate>Tue, 04 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-08-04/2015-08-04-ios-attribute-objc-designated-initializer/</guid>
      <description>reference
attribute((objc_designated_initializer)) 指定初始化器（designated initializer）是 Objective-C 中的一个重要的概念，但是很可惜的是，很多开发者（不知道为什么）并没能正确遵守关于指定初始化器的一些惯例。
之前，我们只能通过 code review 之类的方法来找出、修正这些问题；现在，clang 为我们提供了编译器级别的支持，能够找出不遵守管理的地方并给出警告，我们需要做的是标记出哪个初始化器是指定初始化器，例如：
@interface FTBObject - (instancetype)init __attribute__((objc_designated_initializer)); @end  通过在接口定义中指定指定初始化器，不仅编译器能够给出相关的警告，而且需要继承该类的开发者也可以不参考文档就知道哪个初始化器是指定初始化器。
目前，clang 可以提供一系列警告，例如非指定初始化器没有调用其他初始化器、指定初始化器没有调用父类的指定初始化器、指定初始化器调用了非指定初始化器、子类没有复写父类的指定初始化器等。 具体的例子可以看这个测试用例。
不幸的是，目前系统库的接口还没有这个属性，也就是说只有继承自己的代码和标记了这个指令的第三方库中的类才有用。</description>
    </item>
    
    <item>
      <title>iOS bit computing</title>
      <link>http://ytlvy.com/posts/2015-08-04/2015-08-04-ios-bit-computing/</link>
      <pubDate>Tue, 04 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-08-04/2015-08-04-ios-bit-computing/</guid>
      <description>&lt;h2 id=&#34;ios-位与位运算&#34;&gt;iOS 位与位运算&lt;/h2&gt;

&lt;h3 id=&#34;介绍&#34;&gt;介绍&lt;/h3&gt;

&lt;p&gt;位操作是程序设计中对位模式或二进制数的一元和二元操作. 在许多古老的微处理器上, 位运算比加减运算略快, 通常位运算比乘除法运算要快很多. 在现代架构中, 情况并非如此:位运算的运算速度通常与加法运算相同(仍然快于乘法运算).（摘自wikipedia）
OC作为c的扩展和超集，位运算自然使用的是c的操作符。c提供了6个位操作符，$，|，^，~，&amp;lt;&amp;lt;，&amp;gt;&amp;gt;。本文不打算做位运算的基础教学，只介绍一些开发中能用到的场景。&lt;/p&gt;

&lt;h3 id=&#34;提高运算速度&#34;&gt;提高运算速度&lt;/h3&gt;

&lt;p&gt;如前一段所说，位运算的运算速度是通常与加法速度相当，但是快于乘法运算的。故而如果我们的程序对性能有要求，我们可以使用位运算来提高运算速度。比如：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;乘以2：n &amp;lt;&amp;lt; 1;&lt;/li&gt;
&lt;li&gt;除以2：n &amp;gt;&amp;gt; 1;&lt;/li&gt;
&lt;li&gt;乘以2的m次方：n &amp;lt;&amp;lt; m;&lt;/li&gt;
&lt;li&gt;除以2的m次方：n &amp;gt;&amp;gt; m;&lt;/li&gt;
&lt;li&gt;判断奇偶：(n &amp;amp; 1) == 1;&lt;/li&gt;
&lt;li&gt;求平均数：(a + b) &amp;gt;&amp;gt; 1;&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;基于乘除法的位运算提速还有很多，这里不一一列举。需要注意的是，你应当只在遇到性能瓶颈的时候，并且瓶颈的确是计算的时候才这么做。因为使用位运算并不利于程序的可读性和可维护性。（科学计算除外）&lt;/p&gt;

&lt;h3 id=&#34;压缩空间&#34;&gt;压缩空间&lt;/h3&gt;

&lt;p&gt;以前接触过ACM的筒子们应该对状态压缩不陌生，状态压缩的目的在于把一个大数据用有限的内存空间来进行表示。比如 Programming Pearls 里面的一个经典示例：如何对最多有一千万条不重复的7位整数（电话号码）进行排序？且可使用的内存空间有大约1MB多。&lt;/p&gt;

&lt;p&gt;显而易见的常规做法既是做一个基于磁盘操作的外排序。然而如果转换一下思路，充分的使用内存中的每一个位，加上不存在重复的电话号码，以及不存在0和1开头的电话号码。我们只需要使用1000万个位（大约1.2mb），就能以集合的方式在内存里标记下所有的数据，从而轻松的实现位排序。此种方法大幅度的减少了IO时间，从而获得巨大的性能提升。&lt;/p&gt;

&lt;p&gt;ACM里面有大量的如果使用位来压缩空间的示例，状态压缩的动态规划等，此处不做展开，只告诉读者，充分的使用内存的每一个位，经常能带来意想不到的收获。但需要注意的是，状态的压缩和提取，都需要一定的计算量，有时一味的追求状态压缩，反而会降低效率。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>ios GPUImage simple use</title>
      <link>http://ytlvy.com/posts/2015-08-04/2015-08-04-ios-gpuimage-simple-use/</link>
      <pubDate>Tue, 04 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-08-04/2015-08-04-ios-gpuimage-simple-use/</guid>
      <description>GPUImage GPUImage 作者是 Brad Larson，以 BSD 协议放出，能够在图像、实时摄像头影像和视频上使用 GPU 加速的滤镜和其他效果.
GPU vs. CPU 每只 iPhone 都有两个处理器：一个 CPU，也就是中央处理器，和一个 GPU，也就是图形处理器。每个处理器都有它自己的优势，现代芯片架构（例如 Apple A4）把 CPU 和 GPU 集成在一个物理封装里。
在 Xcode 里面写 C 和 Objective-C 的时候，产生的指令绝大部分会被 CPU 执行。相对地，GPU 是一枚专用芯片，专门用来做独立的小操作，例如图形渲染。GPU 执行的指令和 CPU 是有很大区别的，因此用特殊的语言来编写：OpenGL（特别地，在 iPhone 和 iPad 上使用 OpenGL ES）
渲染管线 GPUImage 从本质上来说是一个渲染管线的 Objective-C抽象。从相机、网络或者磁盘上加载的源图像，在经过一系列滤镜处理后，最终输出到了 view、graphics context 或是数据流中。
例如说，摄像头中的图像可以应用一个 Color Levels 滤镜，来模拟各种色盲效果，然后实时显示在一个 view 中。
GPUImageVideoCamera *videoCamera = [[GPUImageVideoCamera alloc] initWithSessionPreset:AVCaptureSessionPreset640x480 cameraPosition:AVCaptureDevicePositionBack]; videoCamera.outputImageOrientation = UIInterfaceOrientationPortrait; GPUImageFilter *filter = [[GPUImageLevelsFilter alloc] initWithFragmentShaderFromFile:@&amp;quot;CustomShader&amp;quot;]; [filter setRedMin:0.</description>
    </item>
    
    <item>
      <title>parse crashLog manually</title>
      <link>http://ytlvy.com/posts/2015-08-04/2015-08-04-parse-crashlog-manually/</link>
      <pubDate>Tue, 04 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-08-04/2015-08-04-parse-crashlog-manually/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://foggry.com/blog/2015/07/27/ru-he-shou-dong-jie-xi-crashlog/&#34;&gt;转自&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;如何手动解析crashlog&#34;&gt;如何手动解析CrashLog&lt;/h2&gt;

&lt;p&gt;解决崩溃问题是移动应用开发者最日常的工作之一。如果是开发过程中遇到的崩溃，可以根据重现步骤调试，但线上版本就无能为力了。好在目前已经有很多不错的第三方CrashLog搜集平台（如友盟、Crashlytics等）为我们做好了解析工作，甚至在Xcode7里苹果也跟进了解析线上版本崩溃日志的功能，为开发者减轻了不少负担。尽管通常已经不需要我们手工处理CrashLog，了解CrashLog的还原原理和方法还是有必要的。&lt;/p&gt;

&lt;h3 id=&#34;dsym&#34;&gt;.dSYM&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;.dSYM(debugging SYMbols)&lt;/code&gt;又称为调试符号表，是苹果为了方便调试和定位问题而使用的一种调试方案，本质上使用的是起源于贝尔实验室的DWARF（Debugging With Attributed Record Formats），其在&lt;code&gt;.xcarchive&lt;/code&gt;目录中的层次结构为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.xcarchive
--dSYMs
  |--Your.app.dSYM
    |--Contents
      |--Resources
        |--DWARF
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于DWARF的具体内容以后有机会再说。我们能解析CrashLog全靠.dSYM文件，解析方式见后文。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Chun notes</title>
      <link>http://ytlvy.com/posts/2015-07-28/2015-07-28-chun-notes/</link>
      <pubDate>Tue, 28 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-07-28/2015-07-28-chun-notes/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://blog.callmewhy.com/2015/05/25/note-about-chun/&#34;&gt;转自&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;chun-阅读笔记-如何做一个图片缓存库&#34;&gt;Chun 阅读笔记 - 如何做一个图片缓存库&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/yechunjun/Chun&#34;&gt;Chun&lt;/a&gt; 是 &lt;a href=&#34;http://chun.tips/&#34;&gt;叶纯俊&lt;/a&gt; 在 Github 上开源的一个图片缓存库，基于 Swift 编写。学习 Swift 有一段时间了，记录一些阅读源码的一些收获。&lt;/p&gt;

&lt;h3 id=&#34;代码组织&#34;&gt;代码组织&lt;/h3&gt;

&lt;p&gt;Swift 中通过 &lt;code&gt;extension&lt;/code&gt; 组织代码会让整个类更加清晰可读，尤其是对于 &lt;code&gt;UITableViewDataSource&lt;/code&gt; 和 &lt;code&gt;UITableViewDelegate&lt;/code&gt; 这种情况。在 Chun 这个项目中的 Demo 文件就是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class ViewController: UIViewController {
    override func viewDidLoad() {
        super.viewDidLoad()
        ...
    }
}

extension ViewController: UITableViewDataSource, UITableViewDelegate {
    func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -&amp;gt; Int {
        ...
    }
    func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&amp;gt; UITableViewCell {
        ...
    }
    func tableView(tableView: UITableView, heightForRowAtIndexPath indexPath: NSIndexPath) -&amp;gt; CGFloat {
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>iOS ARC Practices</title>
      <link>http://ytlvy.com/posts/2015-07-28/2015-07-28-ios-arc-practices/</link>
      <pubDate>Tue, 28 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-07-28/2015-07-28-ios-arc-practices/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://amattn.com/p/arc_best_practices.html&#34;&gt;转自&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;arc-最佳实践&#34;&gt;ARC 最佳实践&lt;/h2&gt;

&lt;h3 id=&#34;general&#34;&gt;General&lt;/h3&gt;

&lt;p&gt;1) 数值变量应该使用 assign：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@property (nonatomic, assign) int scalarInt;
@property (nonatomic, assign) CGFloat scalarFloat;
@property (nonatomic, assign) CGPoint scalarStruct;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2) 在层次结构上属于下一级的对象应该使用 strong ：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@property (nonatomic, strong) id childObject;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3) 在层次结构上属于上一级的对象应该使用 weak ，另外，当出现循环引用的时候也应该使用 weak ：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@property (nonatomic, weak) id parentObject;
@property (nonatomic, weak) NSObject &amp;lt;SomeDelegate&amp;gt; *delegate;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4) 闭包应该使用 copy ：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@property (nonatomic, copy) SomeBlockType someBlock;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5) 在 dealloc 里：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;从观察者中移除 (remove observers)&lt;/li&gt;
&lt;li&gt;取消订阅通知 (unregister for notifications)&lt;/li&gt;
&lt;li&gt;设置非 weak 的委托为 nil (set any non-weak delegates to nil)&lt;/li&gt;
&lt;li&gt;关闭所有的计时器 (invalidate any timers)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;6) 所有的 IBOutlet 都应该是 weak 的。除非顶层的 IBOutlet 应该是 strong 的，比如 UIViewController 的 View 是需要直接拥有的，所以应该设置成 strong&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>iOS NSTimer Overflow</title>
      <link>http://ytlvy.com/posts/2015-07-28/2015-07-28-ios-nstimer-overflow/</link>
      <pubDate>Tue, 28 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-07-28/2015-07-28-ios-nstimer-overflow/</guid>
      <description>&lt;h2 id=&#34;nstimer&#34;&gt;NSTimer&lt;/h2&gt;

&lt;h3 id=&#34;fire&#34;&gt;fire&lt;/h3&gt;

&lt;p&gt;我们先用 NSTimer 来做个简单的计时器，每隔5秒钟在控制台输出 Fire 。比较想当然的做法是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@interface DetailViewController ()
@property (nonatomic, weak) NSTimer *timer;
@end

@implementation DetailViewController
- (IBAction)fireButtonPressed:(id)sender {
    _timer = [NSTimer scheduledTimerWithTimeInterval:3.0f
                                              target:self
                                            selector:@selector(timerFire:)
                                            userInfo:nil
                                             repeats:YES];
    [_timer fire];
}

-(void)timerFire:(id)userinfo {
    NSLog(@&amp;quot;Fire&amp;quot;);
}
@end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行之后确实在控制台每隔3秒钟输出一次 &lt;code&gt;Fire&lt;/code&gt; ，然而当我们从这个界面跳转到其他界面的时候却发现：控制台还在源源不断的输出着 Fire 。看来 Timer 并没有停止。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>iOS9 NSAppTransportSecurity Bypass</title>
      <link>http://ytlvy.com/posts/2015-07-28/2015-07-28-ios9-nsapptransportsecurity-bypass/</link>
      <pubDate>Tue, 28 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-07-28/2015-07-28-ios9-nsapptransportsecurity-bypass/</guid>
      <description>&lt;h2 id=&#34;configuring-app-transport-security-exceptions-in-ios-9-and-osx-10-11&#34;&gt;Configuring App Transport Security Exceptions in iOS 9 and OSX 10.11&lt;/h2&gt;

&lt;h3 id=&#34;what-is-app-transport-security-ats&#34;&gt;What is App Transport Security (ATS)?&lt;/h3&gt;

&lt;p&gt;At WWDC 2015, Apple announced “App Transport Security” for iOS 9 and OSX 10.11 El Capitan. The &lt;a href=&#34;https://developer.apple.com/library/prerelease/ios/releasenotes/General/WhatsNewIniOS/Articles/iOS9.html#//apple_ref/doc/uid/TP40016198-SW1&#34;&gt;“What’s New in iOS”&lt;/a&gt; guide for iOS 9 explains:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;App Transport Security (ATS) lets an app add a declaration to its Info.plist file that specifies the domains with which it needs secure communication. ATS prevents accidental disclosure, provides secure default behavior, and is easy to adopt. You should adopt ATS as soon as possible, regardless of whether you’re creating a new app or updating an existing one.
If you’re developing a new app, you should use HTTPS exclusively. If you have an existing app, you should use HTTPS as much as you can right now, and create a plan for migrating the rest of your app as soon as possible.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In simple terms, this means that if your application attempts to connect to any HTTP server (in this example, yourserver.com) that doesn’t support the latest SSL technology (TLSv1.2), your connections will fail with an error like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CFNetwork SSLHandshake failed (-9801)
Error Domain=NSURLErrorDomain Code=-1200 &amp;quot;An SSL error has occurred and a secure connection to the server cannot be made.&amp;quot; UserInfo=0x7fb080442170 {NSURLErrorFailingURLPeerTrustErrorKey=&amp;lt;SecTrustRef: 0x7fb08043b380&amp;gt;, NSLocalizedRecoverySuggestion=Would you like to connect to the server anyway?, _kCFStreamErrorCodeKey=-9802, NSUnderlyingError=0x7fb08055bc00 &amp;quot;The operation couldn’t be completed. (kCFErrorDomainCFNetwork error -1200.)&amp;quot;, NSLocalizedDescription=An SSL error has occurred and a secure connection to the server cannot be made., NSErrorFailingURLKey=https://yourserver.com, NSErrorFailingURLStringKey=https://yourserver.com, _kCFStreamErrorDomainKey=3}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Curiously, you’ll notice that the connection attempts to change the http protocol to https to protect against mistakes in your code where you may have accidentally misconfigured the URL. In some cases, this might actually work, but it’s also confusing.&lt;/p&gt;

&lt;h3 id=&#34;warning-ats-is-good-for-you-and-your-users-and-you-shouldn-t-disable-it&#34;&gt;&lt;strong&gt;WARNING: ATS is good for you and your users and you shouldn’t disable it!&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;The reason why Apple is pushing so aggressively to force secure connections is because it’s the right thing to do. Protecting personal data from being compromised over insecure wireless connections, among other things, is great for users. Just because these exceptions exist doesn’t mean you should actually use them.&lt;/p&gt;

&lt;p&gt;If your application is connecting to third party APIs that you can’t control (such as in my case, where my application Routesy connects to public transit APIs that don’t yet support SSL) or serving as a means to load syndicated content (a browser or a news reader, for instance), these techniques might be useful to you.&lt;/p&gt;

&lt;p&gt;The bottom line is, if you run your own API server, FIX YOUR SSL. Thanks to Dave DeLong for reminding me that I should clarify that disabling ATS is a bad idea.&lt;/p&gt;

&lt;p&gt;That being said…
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>xcode condition breakpoint non-ascii</title>
      <link>http://ytlvy.com/posts/2015-07-28/2015-07-28-xcode-condition-breakpoint-non-ascii/</link>
      <pubDate>Tue, 28 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-07-28/2015-07-28-xcode-condition-breakpoint-non-ascii/</guid>
      <description> 设置变量 expr username = @&amp;quot;username&amp;quot; expr password = @&amp;quot;badpassword&amp;quot;  条件断点 (BOOL)[item isEqualToString:@&amp;quot;three&amp;quot;] //非 ASCII 码写法 (BOOL)[(NSString*)titleName isEqualToString:[NSString stringWithUTF8String:&amp;quot;消息&amp;quot;]]  </description>
    </item>
    
    <item>
      <title>iOS static library architectures</title>
      <link>http://ytlvy.com/posts/2015-07-26/2015-07-26-ios-static-library-architectures/</link>
      <pubDate>Sun, 26 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-07-26/2015-07-26-ios-static-library-architectures/</guid>
      <description> iOS static library architectures 最近入职, 刚接手需要参与的工程, 调试了半天, 发现由于32\64位的问题, 不能在模拟器调试, 很郁闷. 后来google 到答案记录如下:
静态库编译支持arm64,armv7 armv7s, i386, x86_64.
1) 分别在设备和模拟器编译 2) 找到Build/Products目录, 下有两个目录 Release-iphoneos Release-iphonesimulator
/Users/kappe/Library/Developer/Xcode/DerivedData/zbar-gyozyrpbqzvslmfoadhqkwskcesd/Build/Products  3) 合并
lipo -create Release-iphoneos/libzbar.a Release-iphonesimulator/libzbar.a -o libzbar.a  </description>
    </item>
    
    <item>
      <title>iOS wild pointer crash</title>
      <link>http://ytlvy.com/posts/2015-07-21/2015-07-21-ios-wild-pointer-crash/</link>
      <pubDate>Tue, 21 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-07-21/2015-07-21-ios-wild-pointer-crash/</guid>
      <description>转自
先提高野指针Crash率 写c、c++代码的同学应该都清楚，crash最多的原因通常有两种，一种是多线程，一种是野指针。这两种crash都带随机性，而且这两种crash有相当一部分都很难区分，甚至大量的crash只有系统栈，如果不能根据日志重现，几乎是无解，让人非常蛋疼。
本文主要讨论的方向是objc的野指针。objc的野指针最常见的一种栈是objc_msgSend，从Bugly上报的Crash数据来看，objc_msgSend的量占了五分之一，这其中大多数是objc野指针。当然也有相当多的objc野指针不是这种表现，所以野指针的crash体量很惊人
为什么Obj-C野指针的Crash那么多？ 我们有这么多自动化和人工测试流程，而且还有几轮的灰度过程，其实很多crash场景都应该已经覆盖到了，但随机性意味着，测试的时候它没有问题，等用户用了才有问题，这种情况该怎么办？！
我觉得关键在于它的随机性，随机性问题我初略地分为两类：
第一类是跑不进出错的逻辑，执行不到出错的代码，这种可以提高测试场景覆盖度来解决。
第二类是跑进了有问题的逻辑，但是野指针指向的地址并不一定会导致crash，这好像要看人品了？ 一说到人品就头疼啊有木有，由于上辈子做了太多善事，人品太好每次自测的时候根本不crash有木有！
先来分析分析 野指针是指指向一个已删除的对象或未申请访问受限内存区域的指针。本文说的objc野指针，说的是objc对象释放之后指针未置空，导致的野指针（objc里面一般不会出现为初始化对象的常识性错误）。
既然是访问已经释放的对象为什么不是必现crash呢？ 因为dealloc执行后只是告诉系统，这片内存我不用了，而系统并没有就让这片内存不能访问。
现实大概是下面几种可能的情况：
 对象释放后内存没被改动过，原来的内存保存完好，可能不crash或者出现逻辑错误（随机crash）。 对象释放后内存没被改动过，但是它自己析构的时候已经删掉某些必要的东西，可能不crash、crash在访问依赖的对象比如类成员上、出现逻辑错误（随机crash）。 对象释放后内存被改动过，写上了不可访问的数据，直接就出错了很可能crash在objc_msgSend上面（必现crash，常见）。 对象释放后内存被改动过，写上了可以访问的数据，可能不crash、出现逻辑错误、间接访问到不可访问的数据（随机crash）。 对象释放后内存被改动过，写上了可以访问的数据，但是再次访问的时候执行的代码把别的数据写坏了，遇到这种crash只能哭了（随机crash，难度大，概率低）！！ 对象释放后再次release（几乎是必现crash，但也有例外，很常见）。  参考下面的这张图： 看看下面的代码，明显有问题，但是大部分时候是不会crash的。
UIView* testObj=[[UIView alloc] init]; [testObj release]; [testObj setNeedsLayout];  让随机变成不随机 从上面列的情况来看，出现随机Crash的情况有很多种！这是得多蛋疼呢！或许最好的办法让他们全都立马crash，然后把野指针都找出来！ 仔细看看上面的关键路径只有出现被随机填入的数据是不可访问的时候才会必现crash。
这个地方我们可以做一下手脚，把这一随机的过程变成不随机的过程。对象释放后在内存上填上不可访问的数据，其实这种技术其实一直都有，xcode的Enable Scribble就是这个作用。 下面我们就拿刚刚的代码试一下。
scheme=&amp;gt;run=&amp;gt;diagnostics=&amp;gt;Enable Scribble
果然，必现了，0x5555561！！
但是有个问题：这货不能放在测试同学那边用！因为总不能让测试同学装了xcode来测试吧？
于是我们自己动手实现一个，这个过程中我们要解决几个问题：
 怎么在内存释放后填上不可访问的数据？内存释放很可能不在我们的代码中。为此我们需要hook对象释放的接口，内存释放之后马上执行我们的破坏工作。 我们要重写对象释放的接口，重写哪个呢？NSObject的dealloc、runtime的 object_dispose，c的free应该都是可以，但是各有优点，我选择的是覆盖面最广的free，free是c的函数，重写了它之后还可以顺带解决一部分c的野指针问题。 怎么重写？重写c的接口场景的有两种： a. 替换系统动态库 b.hook . 替换动态库太麻烦，还不知道行不行得通；hook我们就找现成的fishhook，github里面找的，但现成的代码需要防止代码冲突。 填充的不可访问的数据的长度怎么确定？获取内存长度的接口不在标准库中，好在在Mac和iOS中可以用malloc_size就可以。 填什么？和xcode一样，填0x55  上hook后的free代码：
void safe_free(void* p){ size_t memSiziee=malloc_size(p); memset(p, 0x55, memSiziee); orig_free(p); return; }  测试一下，出现了和Enable Scribble一样的crash！ 重复造了这个xcode的轮子之后，以后编包给测试，终于在某些情况下不需要那么拼人品了。但是这仅仅覆盖了众多野指针中的一部分，还有大量的疑问等着继续解答。比如：</description>
    </item>
    
    <item>
      <title>iOS CoreText Advance</title>
      <link>http://ytlvy.com/posts/2015-07-19/2015-07-19-ios-coretext-advance/</link>
      <pubDate>Sun, 19 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-07-19/2015-07-19-ios-coretext-advance/</guid>
      <description>版权说明 原创文章，转载请保留以下信息：
本文节选自我的图书：《iOS 开发进阶 》。 本文涉及的 Demo 工程在这里：https://github.com/tangqiaoboy/iOS-Pro。 扫码关注我的「iOS 开发」微信公众帐号： 基于 CoreText 的排版引擎：进阶 本章前言 在上一篇《基于 CoreText 的排版引擎：基础》中，我们学会了排版的基础知识，现在我们来增加复杂性，让我们的排版引擎支持图片和链接的点击。
支持图文混排的排版引擎 改造模版文件 下面我们来进一步改造，让排版引擎支持对于图片的排版。在上一小节中，我们在设置模版文件的时候，就专门在模板文件里面留了一个名为type的字段，用于表示内容的类型。之前的type的值都是txt，这次，我们增加一个值为img的值，用于表示图片。
我们将上一节的content.json文件修改为如下内容，增加了 2 个type值为img的配置项。由于是图片的配置项，所以我们不需要设置颜色，字号这些图片不具有的属性，但是，我们另外增加了 3 个图片的配置属性：
 一个名为width的属性，用于设置图片显示的宽度。 一个名为height的属性，用于设置图片显示的高度。 一个名为name的属性，用于设置图片的资源名。  [ { &amp;quot;type&amp;quot; : &amp;quot;img&amp;quot;, &amp;quot;width&amp;quot; : 200, &amp;quot;height&amp;quot; : 108, &amp;quot;name&amp;quot; : &amp;quot;coretext-image-1.jpg&amp;quot; }, { &amp;quot;color&amp;quot; : &amp;quot;blue&amp;quot;, &amp;quot;content&amp;quot; : &amp;quot; 更进一步地，实际工作中，我们更希望通过一个排版文件，来设置需要排版的文字的 &amp;quot;, &amp;quot;size&amp;quot; : 16, &amp;quot;type&amp;quot; : &amp;quot;txt&amp;quot; }, { &amp;quot;color&amp;quot; : &amp;quot;red&amp;quot;, &amp;quot;content&amp;quot; : &amp;quot; 内容、颜色、字体 &amp;quot;, &amp;quot;size&amp;quot; : 22, &amp;quot;type&amp;quot; : &amp;quot;txt&amp;quot; }, { &amp;quot;color&amp;quot; : &amp;quot;black&amp;quot;, &amp;quot;content&amp;quot; : &amp;quot; 大小等信息。\n&amp;quot;, &amp;quot;size&amp;quot; : 16, &amp;quot;type&amp;quot; : &amp;quot;txt&amp;quot; }, { &amp;quot;type&amp;quot; : &amp;quot;img&amp;quot;, &amp;quot;width&amp;quot; : 200, &amp;quot;height&amp;quot; : 130, &amp;quot;name&amp;quot; : &amp;quot;coretext-image-2.</description>
    </item>
    
    <item>
      <title>iOS CoreText Base</title>
      <link>http://ytlvy.com/posts/2015-07-19/2015-07-19-ios-coretext-base/</link>
      <pubDate>Sun, 19 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-07-19/2015-07-19-ios-coretext-base/</guid>
      <description>转自
转载声明 原创文章，转载请保留以下信息：
本文节选自我的图书：《iOS 开发进阶 》。 本文涉及的 Demo 工程在这里：https://github.com/tangqiaoboy/iOS-Pro。 扫码关注我的「iOS 开发」微信公众帐号： 基于 CoreText 的排版引擎：基础 使用 CoreText 技术，我们可以对富文本进行复杂的排版。经过一些简单的扩展，我们还可以实现对于图片，链接的点击效果。CoreText 技术相对于 UIWebView，有着更少的内存占用，以及可以在后台渲染的优点，非常适合用于内容的排版工作。
本章我们将从最基本的开始，一步一步完成一个支持图文混排、支持图片和链接点击的排版引擎。
CoreText 简介 CoreText 是用于处理文字和字体的底层技术。它直接和 Core Graphics（又被称为 Quartz）打交道。Quartz 是一个 2D 图形渲染引擎，能够处理 OSX 和 iOS 中的图形显示。
Quartz 能够直接处理字体（font）和字形（glyphs），将文字渲染到界面上，它是基础库中唯一能够处理字形的模块。因此，CoreText 为了排版，需要将显示的文本内容、位置、字体、字形直接传递给 Quartz。相比其它 UI 组件，由于 CoreText 直接和 Quartz 来交互，所以它具有高速的排版效果。
下图是 CoreText 的架构图，可以看到，CoreText 处于非常底层的位置，上层的 UI 控件（包括 UILabel，UITextField 以及 UITextView）和 UIWebView 都是基于 CoreText 来实现的。
 注意：这个是 iOS7 之后的架构图，在 iOS7 以前，并没有图中的 Text Kit 类，不过 CoreText 仍然是处在最底层直接和 Core Graphics 打交道的模块。</description>
    </item>
    
    <item>
      <title>ARC dealloc cxx_destruct</title>
      <link>http://ytlvy.com/posts/2015-07-17/2015-07-17-arc-dealloc-cxx-destruct/</link>
      <pubDate>Fri, 17 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-07-17/2015-07-17-arc-dealloc-cxx-destruct/</guid>
      <description>转
ARC下dealloc过程及.cxx_destruct的探究 我是前言 这次探索源自于自己一直以来对ARC的一个疑问，在MRC时代，经常写下面的代码：
- (void)dealloc { self.array = nil; self.string = nil; // ... // // 非Objc对象内存的释放，如CFRelease(...) // ... // [super dealloc]; }  对象析构时将内部其他对象release掉，申请的非Objc对象的内存当然也一并处理掉，最后调用super，继续将父类对象做析构。而现如今到了ARC时代，只剩下了下面的代码：
- (void)dealloc { // ... // // 非Objc对象内存的释放，如CFRelease(...) // ... // }  问题来了：
 这个对象实例变量（Ivars）的释放去哪儿了？ 没有显示的调用[super dealloc]，上层的析构去哪儿了？  ARC文档中对dealloc过程的解释 llvm官方的ARC文档 中对ARC下的dealloc过程做了简单说明，从中还是能找出些有用的信息：
 A class may provide a method definition for an instance method named dealloc. This method will be called after the final release of the object but before it is deallocated or any of its instance variables are destroyed.</description>
    </item>
    
    <item>
      <title>iOS Class Clusters</title>
      <link>http://ytlvy.com/posts/2015-07-17/2015-07-17-ios-class-clusters/</link>
      <pubDate>Fri, 17 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-07-17/2015-07-17-ios-class-clusters/</guid>
      <description>转自
从NSArray看类簇 Class Clusters Class Clusters（类簇）是抽象工厂模式在iOS下的一种实现，众多常用类，如NSString，NSArray，NSDictionary，NSNumber都运作在这一模式下，它是接口简单性和扩展性的权衡体现，在我们完全不知情的情况下，偷偷隐藏了很多具体的实现类，只暴露出简单的接口。
NSArray的类簇 虽然官方文档中拿NSNumber说事儿，但Foundation并没有像图中描述的那样为每个number都弄一个子类，于是研究下NSArray类簇的实现方式。
__NSPlacehodlerArray 熟悉这个模式的同学很可能看过下面的测试代码，将原有的alloc+init拆开写：
id obj1 = [NSArray alloc]; // __NSPlacehodlerArray * id obj2 = [NSMutableArray alloc]; // __NSPlacehodlerArray * id obj3 = [obj1 init]; // __NSArrayI * id obj4 = [obj2 init]; // __NSArrayM *  发现+ alloc后并非生成了我们期望的类实例，而是一个__NSPlacehodlerArray的中间对象，后面的- init或- initWithXXXXX消息都是发送给这个中间对象，再由它做工厂，生成真的对象。这里的__NSArrayI和__NSArrayM分别对应Immutable和Mutable（后面的I和M的意思）
于是顺着思路猜实现，__NSPlacehodlerArray必定用某种方式存储了它是由谁alloc出来的这个信息，才能在init的时候知道要创建的是可变数组还是不可变数组
于是乎很开心的去看了下*obj1的内存布局：
下面是32位模拟器中的内存布局（64位太长不好看就临时改32位了- -），第一个箭头是*obj1，第二个是*obj2
我们知道，对象的前4字节（32位下）为isa指针，指向类对象地址，上图所示的0x0051E768就是__NSPlacehodlerArray类对象地址，可以从lldb下po这个地址来验证。
那么问题来了，这个中间对象并没有储存任何信息诶（除了isa外就都是0了），那它init的时候咋知道该创建什么呢？ 经过研究发现，Foundation用了一个很贱的比较静态实例地址方式来实现，伪代码如下：
static __NSPlacehodlerArray *GetPlaceholderForNSArray() { static __NSPlacehodlerArray *instanceForNSArray; if (!instanceForNSArray) { instanceForNSArray = [[__NSPlacehodlerArray alloc] init]; } return instanceForNSArray; } static __NSPlacehodlerArray *GetPlaceholderForNSMutableArray() { static __NSPlacehodlerArray *instanceForNSMutableArray; if (!</description>
    </item>
    
    <item>
      <title>iOS Super init</title>
      <link>http://ytlvy.com/posts/2015-07-17/2015-07-17-ios-super-init/</link>
      <pubDate>Fri, 17 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-07-17/2015-07-17-ios-super-init/</guid>
      <description>转自
What does it mean when you assign [super init] to self? self = [super init]; 是 Objctive-C 语法中很奇怪的一句.
Converting a method invocation 首先需要了解self参数, 编译器是如何处理的.当你输入下面代码时
MyClass *myObject = [[MyClass alloc] initWithString:@&amp;quot;someString&amp;quot;];  编译器会转换为大致如下的代码:
class myClass = objc_getClass(&amp;quot;MyClass&amp;quot;); SEL allocSelector = @selector(alloc); MyClass *myObject1 = objc_msgSend(myClass, allocSelector); SEL initSelector = @selector(initWithString:); MyClass *myObject2 = objc_msgSend(myObject1, initSelector, @&amp;quot;someString&amp;quot;);  So what is &amp;ldquo;self&amp;rdquo;? 每个方法都有两个隐藏参数: self and _cmd.
例如:
- (id)initWithString:(NSString *)aString;  会转换为:</description>
    </item>
    
    <item>
      <title>iOS category dig</title>
      <link>http://ytlvy.com/posts/2015-07-17/2015-07-17-ios-category-dig/</link>
      <pubDate>Fri, 17 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-07-17/2015-07-17-ios-category-dig/</guid>
      <description>转自
objc category的秘密 category的真面目 objc所有类和对象都是c结构体，category当然也一样，下面是runtime中category的结构：
struct _category_t { const char *name; // 1 struct _class_t *cls; // 2 const struct _method_list_t *instance_methods; // 3 const struct _method_list_t *class_methods; // 4 const struct _protocol_list_t *protocols; // 5 const struct _prop_list_t *properties; // 6 };   name 注意，并不是category小括号里写的名字，而是类的名字 cls 要扩展的类对象，编译期间这个值是不会有的，在app被runtime加载时才会根据name对应到类对象 instance_methods这个category所有的-方法 class_methods这个category所有的+方法 protocols这个category实现的protocol，比较不常用在category里面实现协议，但是确实支持的 properties这个category所有的property，这也是category里面可以定义属性的原因，不过这个property不会@synthesize实例变量，一般有需求添加实例变量属性时会采用objc_setAssociatedObject和objc_getAssociatedObject方法绑定方法绑定，不过这种方法生成的与一个普通的实例变量完全是两码事。  编译器，你对category干了什么？ 举个栗子看，定义下面一个类和它的category，实现忽略，保存为sark.h和sark.m
@interface Sark : NSObject - (void)speak; @end @interface Sark (GayExtention) - (void)burst; @end  请出clang的重写命令：</description>
    </item>
    
    <item>
      <title>iOS kvo dig</title>
      <link>http://ytlvy.com/posts/2015-07-17/2015-07-17-ios-kvo-dig/</link>
      <pubDate>Fri, 17 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-07-17/2015-07-17-ios-kvo-dig/</guid>
      <description>转自
objc kvo简单探索 KVO(Key Value Observing)，是观察者模式在Foundation中的实现
KVO的原理 简而言之就是：
 当一个object有观察者时，动态创建这个object的类的子类 对于每个被观察的property，重写其set方法 在重写的set方法中调用- willChangeValueForKey:和- didChangeValueForKey:通知观察者 当一个property没有观察者时，删除重写的方法 当没有observer观察任何一个property时，删除动态创建的子类  空说无凭，简单验证下。
@interface Sark : NSObject @property (nonatomic, copy) NSString *name; @end @implementation Sark @end Sark *sark = [Sark new]; // breakpoint 1 [sark addObserver:self forKeyPath:@&amp;quot;name&amp;quot; options:NSKeyValueObservingOptionNew context:nil]; // breakpoint 2 sark.name = @&amp;quot;萨萨萨&amp;quot;; [sark removeObserver:self forKeyPath:@&amp;quot;name&amp;quot;]; // breakpoint 3  断住后分别使用- class和object_getClass()打出sark对象的Class和真实的Class
// breakpoint 1 (lldb) po sark.class Sark (lldb) po object_getClass(sark) Sark // breakpoint 2 (lldb) po sark.</description>
    </item>
    
    <item>
      <title>ios arc dig</title>
      <link>http://ytlvy.com/posts/2015-07-17/2015-07-17-ios-arc-dig/</link>
      <pubDate>Fri, 17 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-07-17/2015-07-17-ios-arc-dig/</guid>
      <description>转自
objc arc的简单探索 ARC or not？ Automatic Reference Counting是objc发展以来相当重要的一个进步
 对于开发者，任何能降低开发难度，简化代码的功能，我们都应该去了解和使用。 我们应该利用一切“偷懒”的机会，将软件开发的复杂度分解并控制在一个个小的范围内，使得对于分解后的每一个小的任务，都能被新手掌握和维护。
 基于简化开发的思想来看，ARC绝对是一个没理由拒绝的技术进步。 ARC随着iOS5问世，到现在iOS8都快出了，你还在手动写retain，release么？除了固守思想外，对ARC的恐惧大都来自对它的未知。
比如我在公司尝试说服team使用ARC时被质疑的几个问题：
 ARC和Java的GC一样，会导致一部分性能损耗？ 首先，ARC和GC是两码事，ARC是编译时编译器“帮你”插入了原本需要自己手写的内存管理代码，而非像GC一样运行时的垃圾回收系统
 ARC内存不知道什么时候释放，导致不可控的内存涨落？ 了解ARC的原理后，就知道，ARC下编译器插入的内存管理的代码是经过优化的，对于使用完的内存，多运行一行代码都不会浪费，可以这么说，手写的内存管理必须达到很严谨的水平才可能达到ARC自动生成的一样完整且没有疏漏
 ARC下面自己不管理内存，很不爽，很没有安全感 这纯粹是习惯的问题了，开发者的目标是用最简化的手段完成一个最可靠的程序，进步需要改变的。好在编译选项中提供了-fobjc-arc和-fno-objc-arc来保证整个的变革的继续下去，就像社会主义中国里的港澳
  ARC的约定 使用ARC之后一个费解的地方是，一个方法生成的对象，没有任何附加标示，ARC怎么知道生成的对象是不是autorelease的呢？
@interface Sark : NSObject + (instancetype)sarkWithMark:(NSString *)mark; // 1 - (instancetype)initWithMark:(NSString *)mark; // 2 @end  这是非ARC时常用的手段，1生成autorelease对象，2生成普通对象，而现在ARC不能调用autorelease，使用时怎么能知道呢？
{ // ... Sark *sark1 = [Sark sarkWithMark:@&amp;quot;萨萨萨&amp;quot;]; Sark *sark2 = [[Sark alloc] initWithMark:@&amp;quot;萨萨萨&amp;quot;]; }  使用约定，NS定义了下面三个编译属性
#define NS_RETURNS_RETAINED __attribute__((ns_returns_retained)) #define NS_RETURNS_NOT_RETAINED __attribute__((ns_returns_not_retained)) #define NS_RETURNS_INNER_POINTER __attribute__((objc_returns_inner_pointer))  这三个属性是Clang自己使用的标示，除非特殊情况不要自己使用，但是这些对理解ARC是很有帮助的。 这里还要介绍一个概念，Method family</description>
    </item>
    
    <item>
      <title>ios attribute cleanup</title>
      <link>http://ytlvy.com/posts/2015-07-17/2015-07-17-ios-attribute-cleanup/</link>
      <pubDate>Fri, 17 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-07-17/2015-07-17-ios-attribute-cleanup/</guid>
      <description>转自
黑魔法attribute((cleanup)) 编译器属性attribute用于向编译器描述特殊的标识、检查或优化，几个常用的用法看mattt大神的文章就好。今天发现一个名为cleanup的黑魔法属性，简单介绍下。
基本用法 __attribute__((cleanup(...)))，用于修饰一个变量，在它的作用域结束时可以自动执行一个指定的方法，如：
// 指定一个cleanup方法，注意入参是所修饰变量的地址，类型要一样 // 对于指向objc对象的指针(id *)，如果不强制声明__strong默认是__autoreleasing，造成类型不匹配 static void stringCleanUp(__strong NSString **string) { NSLog(@&amp;quot;%@&amp;quot;, *string); } // 在某个方法中： { __strong NSString *string __attribute__((cleanup(stringCleanUp))) = @&amp;quot;sunnyxx&amp;quot;; } // 当运行到这个作用域结束时，自动调用stringCleanUp  所谓作用域结束，包括大括号结束、return、goto、break、exception等各种情况。 当然，可以修饰的变量不止NSString，自定义Class或基本类型都是可以的：
// 自定义的Class static void sarkCleanUp(__strong Sark **sark) { NSLog(@&amp;quot;%@&amp;quot;, *sark); } __strong Sark *sark __attribute__((cleanup(sarkCleanUp))) = [Sark new]; // 基本类型 static void intCleanUp(NSInteger *integer) { NSLog(@&amp;quot;%d&amp;quot;, *integer); } NSInteger integer __attribute__((cleanup(intCleanUp))) = 1;  假如一个作用域内有若干个cleanup的变量，他们的调用顺序是先入后出的栈式顺序； 而且，cleanup是先于这个对象的dealloc调用的。</description>
    </item>
    
    <item>
      <title>ios self in arc</title>
      <link>http://ytlvy.com/posts/2015-07-17/2015-07-17-ios-self-in-arc/</link>
      <pubDate>Fri, 17 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-07-17/2015-07-17-ios-self-in-arc/</guid>
      <description>转自
ARC对self的内存管理 记录下前两天的一次讨论，源于网络库YTKNetwork中“YTKRequest.m”的 - start 方法其中的几行代码：
- (void)start { // ...... YTKRequest *strongSelf = self; [strongSelf.delegate requestFinished:strongSelf]; if (strongSelf.successCompletionBlock) { strongSelf.successCompletionBlock(strongSelf); } [strongSelf clearCompletionBlock]; }  具体的问题大概是这样：
 调用方（如view controller）实例化并强引用YTKRequest对象，将自己作为其delegate 调用方调用YTKRequest的 - start 方法发起网络请求 调用方在 - requestFinished: 中执行了self.request = nil; YTKRequest中，- start方法在回调完-requestFinished: 后 BAD_ACCESS了  也就是说，- start方法还未返回时，self就被外部释放了。作者发现了这个潜在的问题，所以在方法局部增设了一个strongSelf的强引用来保证self的生命周期延续到方法结束。问题是解决了，但是更希望知道原因。
简化说明就是：
- (void)foo { // self被delegate持有 [self.delegate callout]; // 外部释放了这个对象 // 这里self野指针 }  现在想想还是比较不符合常理，入参的self居然不能保证这个函数执行完成。后来查阅了下文档，发现是ARC的(gao)机(de)制(gui)，clang的《这篇ARC文档》中有明确的解释，总结如下：
 ARC下，self既不是strong也不是weak，而是unsafe_unretained的，也就是说，入参的self被表示为：（init系列方法的self除外）  - (void)start { const __unsafe_unretained YTKRequest *self; // .</description>
    </item>
    
    <item>
      <title>objc@interface的设计哲学与设计技巧</title>
      <link>http://ytlvy.com/posts/2015-07-17/2015-07-17-ios-interface-dig/</link>
      <pubDate>Fri, 17 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-07-17/2015-07-17-ios-interface-dig/</guid>
      <description>转自
objc@interface的设计哲学与设计技巧 我是前言 学习objc时，尤其是先学过其他编程语言再来看objc时，总会对objc的类声明的关键字interface感到有点奇怪，在其它面向对象的语言中通常由class关键字来表示，而interface在java中表示的却大约相当于objc的protocol，这个关键字的区别究竟代表了objc语言的设计者怎样的思想呢，在objc类设计中需要注意哪些问题呢？接下来对这个问题进行一些思考和探究.
interface? 先来段Wiki:
 In object-oriented programming, a protocol or interface is a common means for unrelated objects to communicate with each other. These are definitions of methods and values which the objects agree upon in order to cooperate.
 接口约定了对象间交互的属性和方法，使得对象间无需了解对方就可以协作。 说的洋气点就是解耦嘛，细心点也能发现Wiki中interface和protocol表示了相近的语义。 引用我和项目组架构师讨论有关interface的问题时他的说法:
 interface就是一个object定义的可以被外界影响的方式
 说着他指了下旁边桌子上放着的一把伞，说，这把伞我可以打开它，打开这个动作就是它的一个interface，桌子旁边还放着一个盒子，虽然它和伞都放在这张桌子上，但是它们之间永远不会互相影响，所以：
 interface只存在于能互相影响的两者间
 @interface生成了class？ 学习objc时最早接触的就是怎么写一个类了，从.h中写@interface声明类，再从.m中写@implementation实现方法，所以，objc中写一个@interface就相当于c++中写一个class。但这是真的么？
写个小test验证一下： 有两个类，Sark和Dark，Sark类只有.m文件，其中只写@implementation；Dark类只有.h头文件，其中只写@interface，然后如下测试代码：
Class sarkClass = NSClassFromString(@&amp;quot;Sark&amp;quot;); Class darkClass = NSClassFromString(@&amp;quot;Dark&amp;quot;);  NSClassFromString方法调用了runtime方法，根据类名将加载进runtime的这个类找出来，没有这个类就回返回空(Nil)。 结果是sarkClass存在，而darkClass为空，说明什么？是否说明其实@implementation才是真正的Class？ 进一步，不止能取到这个没有@interface的类，还可以正常调用方法（因为万能的runtime）</description>
    </item>
    
    <item>
      <title>Debug</title>
      <link>http://ytlvy.com/posts/2015-07-16/2015-07-16-debug/</link>
      <pubDate>Thu, 16 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-07-16/2015-07-16-debug/</guid>
      <description>调试 DTrace You can use DTrace to monitor a running application to see the methods and the classes that are called. You can easily monitor an iOS app running in the Simulator using DTrace on the command line, First you will need to find the PID of the application using ps and then you can run a DTrace probe like the following:
sudo dtrace -q -n &#39;objc1234:::entry { printf(&amp;quot;%s %s\n&amp;quot;, probemod, probefunc); }&#39;  where 1234 is the process ID of the app.</description>
    </item>
    
    <item>
      <title>LLDB</title>
      <link>http://ytlvy.com/posts/2015-07-16/2015-07-16-lldb/</link>
      <pubDate>Thu, 16 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-07-16/2015-07-16-lldb/</guid>
      <description>build Programs normally have to be compiled with a special option to allow debugging to take place. On UNIX, the option for clang++ is the -g option. For example
clang++ -Wall -g -o prog1 prog1.cpp  We also include the -Wall option, which lists warnings (the &amp;lsquo;all&amp;rsquo; is to list all warnings). Note that this option leads to executable files that are larger and slower, so you may not want to use it for final distributions or time-critical programs.</description>
    </item>
    
    <item>
      <title>iOS Crash文件的解析</title>
      <link>http://ytlvy.com/posts/2015-07-15/2015-07-15-ios-crash%E6%96%87%E4%BB%B6%E7%9A%84%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Wed, 15 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-07-15/2015-07-15-ios-crash%E6%96%87%E4%BB%B6%E7%9A%84%E8%A7%A3%E6%9E%90/</guid>
      <description>&lt;p&gt;-&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.cnblogs.com/smileEvday/p/Crash1.html&#34;&gt;转自&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;ios-crash文件的解析&#34;&gt;iOS Crash文件的解析&lt;/h1&gt;

&lt;p&gt;开发程序的过程中不管我们已经如何小心，总是会在不经意间遇到程序闪退。脑补一下当你在一群人面前自信的拿着你的App做功能预演的时候，流畅的操作被无情地Crash打断。联想起老罗在发布Smartisan OS的时候说了，他准备了10个手机，如果一台有问题，就换一台，如果10台后挂了他就不做手机了。好了不闲扯了，今天就跟大家一起聊聊iOSCrash文件的组成以及常用的分析工具。&lt;/p&gt;

&lt;p&gt;　　有一个WWDC 2010的视频推荐大家抽空看看，视频名称&lt;a href=&#34;https://developer.apple.com/videos/wwdc/2010/?id=317&#34;&gt;&amp;ldquo;Understanding Crash Reports on iPhone OS&amp;rdquo;&lt;/a&gt;，该视频详细讲解了Crash文件的结构。当然如果你没时间看的话，不妨阅读以下这篇文章。&lt;/p&gt;

&lt;h2 id=&#34;crash文件结构&#34;&gt;Crash文件结构&lt;/h2&gt;

&lt;p&gt;当程序运行Crash的时候，系统会把运行的最后时刻的运行信息记录下来，存储到一个文件中，也就是我们所说的Crash文件。iOS的Crash日志通常由以下6各部分组成。 &lt;/p&gt;</description>
    </item>
    
    <item>
      <title>iOS 内存警告</title>
      <link>http://ytlvy.com/posts/2015-07-15/2015-07-15-ios-%E5%86%85%E5%AD%98%E8%AD%A6%E5%91%8A/</link>
      <pubDate>Wed, 15 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-07-15/2015-07-15-ios-%E5%86%85%E5%AD%98%E8%AD%A6%E5%91%8A/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://www.cnblogs.com/smileEvday/archive/2012/03/07/MemoryWarning.html&#34;&gt;转自&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;内存警告&#34;&gt;内存警告&lt;/h1&gt;

&lt;p&gt;系统有四种内存警告&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typedef enum {
　   OSMemoryNotificationLevelAny      = -1,
　   OSMemoryNotificationLevelNormal   =  0,
　   OSMemoryNotificationLevelWarning  =  1,
　   OSMemoryNotificationLevelUrgent   =  2,
　   OSMemoryNotificationLevelCritical =  3
} OSMemoryNotificationLevel;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　通常我们在程序中接收到最多的就是Memory warning level 1，这个时候就证明系统内存紧张了，我们的程序必须做出相应，释放不必要的内存。通常如果我们处理得当的话，内存警告就会到此停止，恢复正常状态。如果我们在接收到&lt;code&gt;memory warning level 1&lt;/code&gt;以后坐视不理的话，系统可能还会再尝试通知几次&lt;code&gt;level 1&lt;/code&gt;，如果还是不去处理的话，系统将会发出更高一级的内存警告&lt;code&gt;level 2&lt;/code&gt;，通常的结果就是我们的App被强制退出，系统收回内存。当然系统在发出level 2的警告时，也会取尝试做一些清理内存的事，例如关闭不必要的后台程序等。很显然我们不该寄希望于系统自己清理，这就好比你的胳膊被划破了，身体肯定会有自修复功能，但是如果伤口比较大的话，肯定还是需要人工处理一下的。&lt;/p&gt;

&lt;p&gt;到目前位置我还没有见过level 3的警告，根据stack over flow上面讲的&amp;rdquo;当发生level 3警告时，系统内核将会接管，很有可能关掉IOS的主界面进程（SpringBorad），甚至会重启&amp;rdquo;，照这个意思来说我们程序里面接收不到，也实属正常，系统自己的东西都被干掉了，我们肯定早被kill了。  KennyTM写的原文地址： &lt;a href=&#34;http://stackoverflow.com/questions/2915247/iphone-os-memory-warnings-what-do-the-different-levels-mean&#34;&gt;http://stackoverflow.com/questions/2915247/iphone-os-memory-warnings-what-do-the-different-levels-mean&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>iOS 应用崩溃日志揭秘</title>
      <link>http://ytlvy.com/posts/2015-07-15/2015-07-15-ios-%E5%BA%94%E7%94%A8%E5%B4%A9%E6%BA%83%E6%97%A5%E5%BF%97%E6%8F%AD%E7%A7%98/</link>
      <pubDate>Wed, 15 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-07-15/2015-07-15-ios-%E5%BA%94%E7%94%A8%E5%B4%A9%E6%BA%83%E6%97%A5%E5%BF%97%E6%8F%AD%E7%A7%98/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://www.raywenderlich.com/23704/demystifying-ios-application-crash-logs&#34;&gt;翻译自&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;ios应用崩溃日志揭秘1&#34;&gt;iOS应用崩溃日志揭秘1&lt;/h1&gt;

&lt;p&gt;作为一名应用开发者，你是否有过如下经历?&lt;/p&gt;

&lt;p&gt;为确保你的应用正确无误，在将其提交到应用商店之前，你必定进行了大量的测试工作。它在你的设备上也运行得很好，但是，上了应用商店后，还是有用户抱怨会闪退 !&lt;/p&gt;

&lt;p&gt;如果你跟我一样是个完美主义者，你肯定想将应用做到尽善尽美。于是你打开代码准备修复闪退的问题&amp;hellip;&amp;hellip;但是，从何处着手呢？ 这时iOS崩溃日志派上用场了。在大多数情况下，你能从中了解到关于闪退的详尽、有用的信息。&lt;/p&gt;

&lt;p&gt;通过本教程，你将学习到一些常见的崩溃日志案例，以及如何从开发设备和iTunes Connect上获取崩溃日志文件。你还将学习到符号化（ symbolication）,从日志追踪到代码 。你还将学习调试一个在待定情况下会闪退的应用。&lt;/p&gt;

&lt;p&gt;让我们开始动手吧!&lt;/p&gt;

&lt;h2 id=&#34;什么是崩溃日志-从哪里能得它&#34;&gt;什么是崩溃日志，从哪里能得它?&lt;/h2&gt;

&lt;p&gt;iOS设备上的应用闪退时，操作系统会生成一个崩溃报告，也叫崩溃日志，保存在设备上。 崩溃日志上有很多有用的信息，包括应用是什么情况下闪退的。通常，上面有每个正在执行线程的完整堆栈跟踪信息，所以你能从中了解到闪退发生时各线程都在做什么，并分辨出闪退发生在哪个线程上。&lt;/p&gt;

&lt;p&gt;有几种方法可以从设备上获取崩溃日志。 设备与电脑上的iTunes Store同步后，会将崩溃日志保存在电脑上。根据电脑操作系统的不同，崩溃日志将保存在以下位置:&lt;/p&gt;

&lt;p&gt;Mac OS X:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~/Library/Logs/CrashReporter/MobileDevice/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>iOS 绘制1像素的线</title>
      <link>http://ytlvy.com/posts/2015-07-15/2015-07-15-ios-%E7%BB%98%E5%88%B61%E5%83%8F%E7%B4%A0%E7%9A%84%E7%BA%BF/</link>
      <pubDate>Wed, 15 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-07-15/2015-07-15-ios-%E7%BB%98%E5%88%B61%E5%83%8F%E7%B4%A0%E7%9A%84%E7%BA%BF/</guid>
      <description>iOS 绘制1像素的线 Point Vs Pixel iOS中当我们使用Quartz，UIKit，CoreAnimation等框架时，所有的坐标系统采用Point来衡量。系统在实际渲染到设置时会帮助我们处理Point到Pixel的转换。 这样做的好处隔离变化，即我们在布局的事后不需要关注当前设备是否为Retina，直接按照一套坐标系统来布局即可。
实际使用中我们需要牢记下面这一点:
One point does not necessarily correspond to one physical pixel.  1 Point的线在非Retina屏幕则是一个像素，在Retina屏幕上则可能是2个或者3个，取决于系统设备的DPI。
iOS系统中，UIScreen，UIView，UIImage，CALayer类都提供相关属性来获取scale factor。 原生的绘制技术天然的帮我们处理了scale factor，例如在drawRect:方法中，UIKit自动的根据当前运行的设备设置了正切的scale factor。所以我们在drawRect: 方法中绘制的任何内容都会被自动缩放到设备的物理屏幕上。
基于以上信息可以看出，我们大部分情况下都不需要去关注pixel，然而存在部分情况需要考虑像素的转化。
例如画1个像素的分割线  看到这个问题你的第一想法可能是，直接根据当前屏幕的缩放因子计算出1 像素线对应的Point，然后设置线宽即可。 代码如下:
1.0f / [UIScreen mainScreen].scale  表面上看着一切正常了，但是通过实际的设备测试你会发现渲染出来的线宽并不是1个像素。
 Why?
 为了获得良好的视觉效果，绘图系统通常都会采用一个叫&amp;rdquo;antialiasing(反锯齿)&amp;ldquo;的技术，iOS也不例外。 显示屏幕有很多小的显示单元组成，可以接单的理解为一个单元就代表一个像素。如果要画一条黑线，条线刚好落在了一列或者一行显示显示单元之内，将会渲染出标准的一个像素的黑线。 但如果线落在了两个行或列的中间时，那么会得到一条&amp;rdquo;失真&amp;rdquo;的线，其实是两个像素宽的灰线。
如下图所示:  Positions defined by whole-numbered points fall at the midpoint between pixels. For example, if you draw a one-pixel-wide vertical line from (1.0, 1.</description>
    </item>
    
    <item>
      <title>NSRunLoop深入理解</title>
      <link>http://ytlvy.com/posts/2015-07-13/2015-07-13-nsrunloop%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/</link>
      <pubDate>Mon, 13 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-07-13/2015-07-13-nsrunloop%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://www.cocoachina.com/ios/20150601/11970.html&#34;&gt;转自&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;runloop&#34;&gt;RunLoop&lt;/h2&gt;

&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;RunLoop 是 iOS 和 OS X 开发中非常基础的一个概念，这篇文章将从 CFRunLoop 的源码入手，介绍 RunLoop 的概念以及底层实现原理。之后会介绍一下在 iOS 中，苹果是如何利用 RunLoop 实现自动释放池、延迟回调、触摸事件、屏幕刷新等功能的。&lt;/p&gt;

&lt;h3 id=&#34;runloop-的概念&#34;&gt;RunLoop 的概念&lt;/h3&gt;

&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出，通常的代码逻辑是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function loop() {
    initialize();
    do {
        var message = get_next_message();
        process_message(message);
    } while (message != quit);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;这种模型通常被称作 Event Loop。 Event Loop 在很多系统和框架里都有实现，比如 Node.js 的事件处理，比如 Windows 程序的消息循环，再比如 OSX/iOS 里的 RunLoop。实现这种模型的关键点在于：如何管理事件/消息，如何让线程在没有处理消息时休眠以避免资源占用、在有消息到来时立刻被唤醒&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;所以，RunLoop 实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行上面 Event Loop 的逻辑。线程执行了这个函数后，就会一直处于这个函数内部 &amp;ldquo;接受消息-&amp;gt;等待-&amp;gt;处理&amp;rdquo; 的循环中，直到这个循环结束（比如传入 quit 的消息），函数返回。

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;OSX/iOS 系统中，提供了两个这样的对象：NSRunLoop 和 CFRunLoopRef。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>iOS Associated Objects</title>
      <link>http://ytlvy.com/posts/2015-07-13/2015-07-13-ios-associated-objects/</link>
      <pubDate>Mon, 13 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-07-13/2015-07-13-ios-associated-objects/</guid>
      <description>&lt;h2 id=&#34;ios-associated-objects&#34;&gt;iOS Associated Objects&lt;/h2&gt;

&lt;p&gt;关注以下三个问题:
1. 关联对象被存储在什么地方，是不是存放在被关联对象本身的内存中？
2. 关联对象的五种关联策略有什么区别，有什么坑？
3. 关联对象的生命周期是怎样的，什么时候被释放，什么时候被移除？&lt;/p&gt;

&lt;h3 id=&#34;使用场景&#34;&gt;使用场景:&lt;/h3&gt;

&lt;p&gt;按照 Mattt Thompson 大神的文章 Associated Objects 中的说法，&lt;a href=&#34;http://nshipster.com/associated-objects/&#34;&gt;Associated Objects&lt;/a&gt; 主要有以下三个使用场景&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;为现有的类添加私有变量以帮助实现细节；&lt;/li&gt;
&lt;li&gt;为现有的类添加公有属性；&lt;/li&gt;
&lt;li&gt;为 KVO 创建一个关联的观察者。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;从本质上看，第 1 、2 个场景其实是一个意思，唯一的区别就在于新添加的这个属性是公有的还是私有的而已。就目前来说，我在实际工作中使用得最多的是第 2 个场景，而第 3 个场景我还没有使用过
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>iOS Category</title>
      <link>http://ytlvy.com/posts/2015-07-13/2015-07-13-ios-category/</link>
      <pubDate>Mon, 13 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-07-13/2015-07-13-ios-category/</guid>
      <description>&lt;h2 id=&#34;category&#34;&gt;category&lt;/h2&gt;

&lt;h3 id=&#34;category-简介&#34;&gt;category 简介&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;为已存在的类, 添加方法&lt;/li&gt;
&lt;li&gt;将类的实现, 分别存放在不同的文件中. 好处: a) 减少单体文件体积 b)按照功能划分 c)协作开发 d)按需加载&lt;/li&gt;
&lt;li&gt;声明私有方法&lt;/li&gt;
&lt;li&gt;模拟多继承&lt;/li&gt;
&lt;li&gt;把framework的私有方法公开&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;extension&#34;&gt;extension&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;extension 很像匿名的category. 差异: a)extension在编译器决议, 是类声明的一部分.b)用来隐藏私有属性或方法.c)只有在有类源码的前提下,才能添加extension&lt;/p&gt;

&lt;p&gt;category 在运行期决议的. category无法添加实例变量, (通过association来模拟添加)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>iOS Event Delivery/ The Responder Chain</title>
      <link>http://ytlvy.com/posts/2015-07-13/2015-07-13-ios-event-delivery-the-responder-chain/</link>
      <pubDate>Mon, 13 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-07-13/2015-07-13-ios-event-delivery-the-responder-chain/</guid>
      <description>&lt;h2 id=&#34;event-delivery-the-responder-chain&#34;&gt;Event Delivery: The Responder Chain&lt;/h2&gt;

&lt;p&gt;当你设计应用的时候, 应用需要动态响应事件. 例如: 点击事件, (可以在显示屏上的不同对象上多次触发), 你需要决定那个对象来响应此事件, 并且需要了解这个对象是如何接收事件的.&lt;/p&gt;

&lt;p&gt;当用户触发一个事件时, UIKit 创建一个&lt;code&gt;event object&lt;/code&gt;, 此对象包含了需要处理的信息. 然后将此事件对象放入到当前 app 的事件队列中. 例如&lt;code&gt;touch&lt;/code&gt;事件, 这种事件对象就是一个包含了一组&lt;code&gt;touch&lt;/code&gt;的&lt;code&gt;UIEvent&lt;/code&gt; 对象. &lt;code&gt;motion&lt;/code&gt;事件, 此对象由你使用的&lt;code&gt;framework&lt;/code&gt;和你感兴趣的&lt;code&gt;motion&lt;/code&gt;类型来决定.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Touch events. 当前 window 对象首先尝试将事件传送给 &lt;code&gt;touch&lt;/code&gt; 触发的视图.这个视图被称为&lt;code&gt;hit-test&lt;/code&gt; 视图. 寻找&lt;code&gt;hit-test&lt;/code&gt;视图的过程被称为&lt;code&gt;hit-testing&lt;/code&gt;, 将在下面描述.&lt;/li&gt;
&lt;li&gt;Motion and remote control events. 对于这些事件, 当前 window 对象会将 &lt;code&gt;shaking-motion&lt;/code&gt; 或 &lt;code&gt;emote control event&lt;/code&gt; 发送给&lt;code&gt;first responder&lt;/code&gt;来响应.&lt;code&gt;first responder&lt;/code&gt;也将在下面描述.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;hit-testing-returns-the-view-where-a-touch-occurred&#34;&gt;Hit-Testing Returns the View Where a Touch Occurred&lt;/h3&gt;

&lt;p&gt;iOS 通过&lt;code&gt;hit-testing&lt;/code&gt; 来寻找点击下方的视图. &lt;code&gt;Hit-Testing&lt;/code&gt; 会查找任何包含该&lt;code&gt;touch&lt;/code&gt;点坐标的视图对象, 规则为此坐标位于视图的&lt;code&gt;bounds&lt;/code&gt;中, 如果包含, 会继续递归检测此视图的所有子视图. 在视图树中包含该点击的最下层视图, 即是&lt;code&gt;hit-test&lt;/code&gt;视图. 当 iOS 决定了 &lt;code&gt;hit-test&lt;/code&gt; 视图后, 会将点击事件发送给此视图来处理.&lt;/p&gt;

&lt;p&gt;说明如下, 假设用户点击了视图 E, iOS 查找&lt;code&gt;hit-test&lt;/code&gt; 视图的逻辑如下:
1. 点击在视图 A 的范围内, 然后检测 子视图 B 和 C
2.  点击不再视图 B 范围内, 但是在视图 C 范围内, 继续检测 子视图 D 和 E
3.  点击不再视图 D 里, 但是在视图 E 中.

视图 E 是最下层且包含 &lt;code&gt;touch&lt;/code&gt;的视图树, 所以就是&lt;code&gt;hit-test&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>iOS Runtime Message And Category</title>
      <link>http://ytlvy.com/posts/2015-07-13/2015-07-13-ios-runtime-message-and-category/</link>
      <pubDate>Mon, 13 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-07-13/2015-07-13-ios-runtime-message-and-category/</guid>
      <description>&lt;h3 id=&#34;习题内容&#34;&gt;习题内容&lt;/h3&gt;

&lt;p&gt;下面的代码会？Compile Error / Runtime Crash / NSLog…?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@interface NSObject (Sark)
+ (void)foo;
@end

@implementation NSObject (Sark)

- (void)foo
{
    NSLog(@&amp;quot;IMP: -[NSObject(Sark) foo]&amp;quot;);
}

@end

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        [NSObject foo];
        [[NSObject new] foo];
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;答案：代码正常输出，输出结果如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2014-11-06 13:11:46.694 Test[14872:1110786] IMP: -[NSObject(Sark) foo]
2014-11-06 13:11:46.695 Test[14872:1110786] IMP: -[NSObject(Sark) foo]
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>iOS Runtime Object &amp; Class &amp; Meta Class</title>
      <link>http://ytlvy.com/posts/2015-07-13/2015-07-13-ios-runtime-object-class-meta-class/</link>
      <pubDate>Mon, 13 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-07-13/2015-07-13-ios-runtime-object-class-meta-class/</guid>
      <description>&lt;h3 id=&#34;习题内容&#34;&gt;习题内容&lt;/h3&gt;

&lt;p&gt;下面代码的运行结果是?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@interface Sark : NSObject
@end

@implementation Sark
@end

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        BOOL res1 = [(id)[NSObject class] isKindOfClass:[NSObject class]];
        BOOL res2 = [(id)[NSObject class] isMemberOfClass:[NSObject class]];

        BOOL res3 = [(id)[Sark class] isKindOfClass:[Sark class]];
        BOOL res4 = [(id)[Sark class] isMemberOfClass:[Sark class]];

        NSLog(@&amp;quot;%d %d %d %d&amp;quot;, res1, res2, res3, res4);
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2014-11-05 14:45:08.474 Test[9412:721945] 1 0 0 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>iOS Runtime Self &amp; Super</title>
      <link>http://ytlvy.com/posts/2015-07-13/2015-07-13-ios-runtime-self-super/</link>
      <pubDate>Mon, 13 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-07-13/2015-07-13-ios-runtime-self-super/</guid>
      <description>&lt;h2 id=&#34;self-super&#34;&gt;Self &amp;amp;&amp;amp; Super&lt;/h2&gt;

&lt;h3 id=&#34;what-is-super&#34;&gt;What is Super?&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Super&lt;/code&gt; 是和 &lt;code&gt;Self&lt;/code&gt; 一样的关键字, 不同的是, 它不能用作函数的参数, 只能接收消息.当接收消息的时候, 它会向父类搜索方法的定义. 如果在向上的类链中没有任何定义, 则程序会 crash.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (instancetype)initWithValue1:(id)value1 value2:(id)value2
{
    self = [super initWithValue1:value1];

    if (self) {
        _value2 = value2;
    }

    return self;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;messaging-super&#34;&gt;messaging &lt;code&gt;super&lt;/code&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;struct objc_super {
    __unsafe_unretained id receiver;
    __unsafe_unretained Class super_class;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;- (void)methodWithArgument:(id)arg
{
    [super otherMethodWithArgument:arg];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;- (void)methodWithArgument:(id)arg
{
    struct objc_super super = {.receiver = self, .super_class = 0xC0FFEE};

    objc_msgSendSuper(&amp;amp;super, @selector(otherMethodWithArgument:), arg);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;objc_msgSendSuper&lt;/code&gt; 将从父类的定义开始查找方法的实现. &lt;code&gt;super_class&lt;/code&gt;是在 runtime 时, 动态生成的.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>iOS Runtime 成员变量与属性</title>
      <link>http://ytlvy.com/posts/2015-07-13/2015-07-13-ios-runtime-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%9E%E6%80%A7/</link>
      <pubDate>Mon, 13 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-07-13/2015-07-13-ios-runtime-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%9E%E6%80%A7/</guid>
      <description>&lt;h3 id=&#34;习题内容&#34;&gt;习题内容&lt;/h3&gt;

&lt;p&gt;下面代码会? Compile Error / Runtime Crash / NSLog…?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@interface Sark : NSObject
@property (nonatomic, copy) NSString *name;
@end

@implementation Sark

- (void)speak {
    NSLog(@&amp;quot;my name is %@&amp;quot;, self.name);
}

@end

@interface Test : NSObject
@end

@implementation Test

- (instancetype)init {
    self = [super init];
    if (self) {
        id cls = [Sark class];
        void *obj = &amp;amp;cls;
        [(__bridge id)obj speak];
    }
    return self;
}

@end

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        [[Test alloc] init];
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;答案：代码正常输出，输出结果为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2014-11-07 14:08:25.698 Test[1097:57255] my name is &amp;lt;Test: 0x1001002d0&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>iOS Runtime 运行时类与对象的编译处理</title>
      <link>http://ytlvy.com/posts/2015-07-13/2015-07-13-ios-runtime-%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BC%96%E8%AF%91%E5%A4%84%E7%90%86/</link>
      <pubDate>Mon, 13 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-07-13/2015-07-13-ios-runtime-%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BC%96%E8%AF%91%E5%A4%84%E7%90%86/</guid>
      <description>&lt;h2 id=&#34;ios-runtime运行时类与对象的编译处理&#34;&gt;iOS Runtime运行时类与对象的编译处理&lt;/h2&gt;

&lt;p&gt;Objective-C语言是一门动态语言，它将很多静态语言在编译和链接时期做的事放到了运行时来处理。这种动态语言的优势在于：我们写代码时更具灵活性，如我们可以把消息转发给我们想要的对象，或者随意交换一个方法的实现等。
这种特性意味着&lt;code&gt;Objective-C&lt;/code&gt;不仅需要一个编译器，还需要一个运行时系统来执行编译的代码。对于Objective-C来说，这个运行时系统就像一个操作系统一样：它让所有的工作可以正常的运行。这个运行时系统即Objc Runtime。Objc Runtime其实是一个Runtime库，它基本上是用C和汇编写的，这个库使得C语言有了面向对象的能力。&lt;/p&gt;

&lt;p&gt;Runtime库主要做下面几件事：
1. 封装：在这个库中，对象可以用C语言中的结构体表示，而方法可以用C函数来实现，另外再加上了一些额外的特性。这些结构体和函数被runtime函数封装后，我们就可以在程序运行时创建，检查，修改类、对象和它们的方法了。
2. 找出方法的最终执行代码：当程序执行[object doSomething]时，会向消息接收者(object)发送一条消息(doSomething)，runtime会根据消息接收者是否能响应该消息而做出不同的反应。这将在后面详细介绍。&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Objective-C runtime目前有两个版本：Modern runtime和Legacy runtime。Modern Runtime 覆盖了64位的Mac OS X Apps，还有 iOS Apps，Legacy Runtime 是早期用来给32位 Mac OS X Apps 用的，也就是可以不用管就是了。
在这一系列文章中，我们将介绍runtime的基本工作原理，以及如何利用它让我们的程序变得更加灵活。在本文中，我们先来介绍一下类与对象，这是面向对象的基础，我们看看在Runtime中，类是如何实现的。
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>iOS property attribute</title>
      <link>http://ytlvy.com/posts/2015-07-13/2015-07-13-ios-property-attribute/</link>
      <pubDate>Mon, 13 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-07-13/2015-07-13-ios-property-attribute/</guid>
      <description>&lt;h2 id=&#34;ios-property-ivar-local-variable&#34;&gt;iOS property &amp;amp;&amp;amp; ivar &amp;amp;&amp;amp; local variable&lt;/h2&gt;

&lt;h3 id=&#34;default-attributes&#34;&gt;default attributes&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;property: atomic assign readwrite&lt;/li&gt;
&lt;li&gt;ivar &amp;amp;&amp;amp; local varibal: strong readwrite non-atomic&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;atomic 在实现中通过加入 lock 的方式来保证多线程安全, 但是这只是很简单的一种线程安全, 只局限于此属性的读写.实际应用场景中, 业务的原子性, 是需要自己来实现的.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;when-to-use-copy&#34;&gt;when to use copy&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;NSStrings: 为了防止其他地方修改&lt;/li&gt;
&lt;li&gt;block: 防止自动释放&lt;/li&gt;
&lt;li&gt;可变数据类型, 当你想阻止其他拥有者变更数据时.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;尽量使用-copy-关键字&#34;&gt;尽量使用 copy 关键字&lt;/h3&gt;

&lt;p&gt;任何实现了&lt;code&gt;NSCopying&lt;/code&gt;协议的类型, 都应该尽量采用&lt;code&gt;copy&lt;/code&gt;. 因为我们定义的属性,在使用时可能是用一个可变的子属性来赋值的, 例如&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@interface Book : NSObject
 
@property (strong, nonatomic) NSString *title;
 
@end


- (void)stringExample {
 
    NSMutableString *bookTitle = [NSMutableString stringWithString:@&amp;quot;Best book ever&amp;quot;];
 
    Book *book = [[Book alloc] init];
    book.title = bookTitle;
 
    [bookTitle setString:@&amp;quot;Worst book ever&amp;quot;];
 
    NSLog(@&amp;quot;book title %@&amp;quot;, book.title);
 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Autorelease</title>
      <link>http://ytlvy.com/posts/2015-07-06/2015-07-06-autorelease/</link>
      <pubDate>Mon, 06 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-07-06/2015-07-06-autorelease/</guid>
      <description>&lt;p&gt;##Autorelease
&lt;img src=&#34;http://blog.sunnyxx.com/tags/objc%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95/page/3/&#34; alt=&#34;转自&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;autorelease对象什么时候释放&#34;&gt;Autorelease对象什么时候释放&lt;/h3&gt;

&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在没有手加Autorelease Pool的情况下，Autorelease对象是在当前的runloop迭代结束时释放的，而它能够释放的原因是系统在每个runloop迭代中都加入了自动释放池Push和Pop&lt;/p&gt;

&lt;p&gt;小实验&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;__weak id reference = nil;
- (void)viewDidLoad {
    [super viewDidLoad];
    NSString *str = [NSString stringWithFormat:@&amp;quot;sunnyxx&amp;quot;];
    // str是一个autorelease对象，设置一个weak的引用来观察它
    reference = str;
}
- (void)viewWillAppear:(BOOL)animated {
    [super viewWillAppear:animated];
    NSLog(@&amp;quot;%@&amp;quot;, reference); // Console: sunnyxx
}
- (void)viewDidAppear:(BOOL)animated {
    [super viewDidAppear:animated];
    NSLog(@&amp;quot;%@&amp;quot;, reference); // Console: (null)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于这个vc在loadView之后便add到了window层级上，所以viewDidLoad和viewWillAppear是在同一个runloop调用的，因此在viewWillAppear中，这个autorelease的变量依然有值。
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Random</title>
      <link>http://ytlvy.com/posts/2015-07-06/2015-07-06-random/</link>
      <pubDate>Mon, 06 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-07-06/2015-07-06-random/</guid>
      <description>&lt;h2 id=&#34;arc4random&#34;&gt;arc4random()&lt;/h2&gt;

&lt;h3 id=&#34;random-int-between-0-and-n-1&#34;&gt;Random int between 0 and N - 1&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;NSUInteger r = arc4random_uniform(N);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;random-int-between-1-and-n&#34;&gt;Random int between 1 and N&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;NSUInteger r = arc4random_uniform(N) + 1;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;random-double-between-0-and-1&#34;&gt;Random double between 0 and 1&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;srand48(time(0));
double r = drand48();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>progress memory map</title>
      <link>http://ytlvy.com/posts/2015-07-06/2015-07-06-progress-memory-map/</link>
      <pubDate>Mon, 06 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-07-06/2015-07-06-progress-memory-map/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://duartes.org/gustavo/blog/post/anatomy-of-a-program-in-memory/&#34;&gt;翻译子&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;程序在内存中分布&#34;&gt;程序在内存中分布&lt;/h2&gt;

&lt;p&gt;内存管理是操作系统的核心. 对系统和编程人员来说这都是非常重要的.下面用 32位 系统举例.首先介绍程序如何在内存中分布.&lt;/p&gt;

&lt;h3 id=&#34;虚拟地址空间&#34;&gt;虚拟地址空间&lt;/h3&gt;

&lt;p&gt;在多任务操作系统中, 每个进程拥有自己独立的内存沙箱. 这个沙箱就是指的&lt;code&gt;虚拟地址空间&lt;/code&gt;(virtual address space), 在32位系统中, 就是一块4GB 大小的内存地址块. 这些虚拟地址和物理内存通过&lt;code&gt;page tables&lt;/code&gt;来完成映射, &lt;code&gt;page tables&lt;/code&gt;是由系统核心管理,进程可以进行访问. 一旦虚拟地址被启用, 会应用到所有的程序中, 包括系统核心. 因此虚拟地址的一部分, 需要被划分出来为系统核心保留使用.
&lt;img src=&#34;http://static.duartes.org/img/blogPosts/kernelUserMemorySplit.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这并不意味着核心会固定占用大量的物理内存, 而是说核心需要按照需要动态映射到足够的物理内存即可.核心空间在 &lt;code&gt;page tables&lt;/code&gt;中被标记为被&lt;code&gt;特权码(privilege code)&lt;/code&gt;独占, 因此如果用户程序尝试访问此空间, &lt;code&gt;页面错误&lt;/code&gt;会被出发并抛出. 在 linux 系统中, 核心空间是常驻内存的, 并且所有程序的核心空间是共享的, 总是映射到同一块物理内存. 核心代码和数据,总是可访问, 并随时准备处理&lt;code&gt;interrupts&lt;/code&gt; 或者 系统调用. 相对的用户程序空间块是每个程序独享的, 并在程序切换时, 而随之切换.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://static.duartes.org/img/blogPosts/virtualMemoryInProcessSwitch.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;上图中蓝色区域标示, 虚拟地址已经完成映射到实际地址, 白色区域代表还没有完成映射.上例中, 以内存消耗多著名的火狐使用了更多的虚拟地址. 在内存地址中不同的区块代表了不同的内存段: heap, stack, 等等.请注意这些内存段只是简单的内存地址范围, 与&lt;code&gt;Intel-style segments&lt;/code&gt;无关. 下面是linux 系统中标准段分布图:&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>what happen before main</title>
      <link>http://ytlvy.com/posts/2015-07-06/2015-07-06-what-happen-before-main/</link>
      <pubDate>Mon, 06 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-07-06/2015-07-06-what-happen-before-main/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://blog.sunnyxx.com/2014/08/30/objc-pre-main/&#34;&gt;转自&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;ios程序main函数之前发生了什么&#34;&gt;iOS程序main函数之前发生了什么&lt;/h2&gt;

&lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;

&lt;p&gt;一个iOS app的&lt;code&gt;main()&lt;/code&gt;函数位于&lt;code&gt;main.m&lt;/code&gt;中，这是我们熟知的程序入口。但对objc了解更多之后发现，程序在进入我们的main函数前已经执行了很多代码，比如熟知的&lt;code&gt;+ load&lt;/code&gt;方法等。本文将跟随程序执行顺序，刨根问底，从&lt;code&gt;dyld&lt;/code&gt;到&lt;code&gt;runtime&lt;/code&gt;，看看main函数之前都发生了什么。&lt;/p&gt;

&lt;h3 id=&#34;从dyld开始&#34;&gt;从dyld开始&lt;/h3&gt;

&lt;h4 id=&#34;动态链接库&#34;&gt;动态链接库&lt;/h4&gt;

&lt;p&gt;iOS中用到的所有系统&lt;code&gt;framework&lt;/code&gt;都是动态链接的，类比成插头和插排，静态链接的代码在编译后的静态链接过程就将插头和插排一个个插好，运行时直接执行二进制文件；而动态链接需要在程序启动时去完成“插插销”的过程，所以在我们写的代码执行前，动态连接器需要完成准备工作。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>IOS 进阶工具篇</title>
      <link>http://ytlvy.com/posts/2015-07-04/2015-07-04-ios-%E8%BF%9B%E9%98%B6%E5%B7%A5%E5%85%B7%E7%AF%87/</link>
      <pubDate>Sat, 04 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-07-04/2015-07-04-ios-%E8%BF%9B%E9%98%B6%E5%B7%A5%E5%85%B7%E7%AF%87/</guid>
      <description>&lt;pre&gt;&lt;code&gt;第一部分：iOS 开发工具
第2章使用CocoaPods 做依赖管理
2.1 CocoaPods 简介
2.2 CocoaPods 的安装和使用
2.2.1 CocoaPods 的安装
2.2.2 使用CocoaPods 的镜像索引
2.2.3 使用CocoaPods
2.2.4 查找第三方库
2.3 注意事项
2.3.1 关于.gitignore
2.3.2 为自己的项目创建podspec 文件
2.3.3 使用私有的pods
2.3.4 不更新podspec
2.3.5 生成第三方库的帮助文档
2.3.6 原理
第3章网络封包分析工具Charles
3.1 Charles 简介
3.2 Charles 的安装和使用
3.2.1 安装Charles
3.2.2 安装SSL 证书
3.2.3 将Charles 设置成系统代理
3.2.4 Charles 主界面介绍
3.2.5 过滤网络请求
3.3 使用Charles 协助iOS 开发
3.3.1 截取iPhone 上的网络封包
3.3.2 模拟慢速网络
3.4 高级功能
3.4.1 截取SSL 信息
3.4.2 修改网络请求内容
3.4.3 修改服务器返回内容
3.5 Map 功能
3.6 Rewrite 功能
3.7 Breakpoints 功能
3.8 总结
3.9 参考链接
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Stack And Heap OverFlow</title>
      <link>http://ytlvy.com/posts/2015-07-03/2015-07-03-stack-and-heap-overflow/</link>
      <pubDate>Fri, 03 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-07-03/2015-07-03-stack-and-heap-overflow/</guid>
      <description>&lt;p&gt;翻译自&lt;a href=&#34;https://developer.apple.com/library/mac/documentation/Security/Conceptual/SecureCodingGuide/Articles/BufferOverflows.html&#34;&gt;https://developer.apple.com/library/mac/documentation/Security/Conceptual/SecureCodingGuide/Articles/BufferOverflows.html&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;栈溢出&#34;&gt;栈溢出&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;在大部分操作系统中, 每个程序拥有一个&lt;strong&gt;&lt;em&gt;栈&lt;/em&gt;&lt;/strong&gt;(多线程程序,每个线程拥有一个单独的栈), 栈用于局部变量的存储.
栈被划分为单元, 此单元被成为帧(frame), 每个帧包含了某个函数的某一调用的全部数据.这些数据包含: 函数参数, 全部的临时变量,和 linkage 信息(就是调用函数的地址. 以便当前代码执行完毕后, 返回原位置继续执行). 通过配置编译参数,也可以包含下一帧的顶部地址.数据的布局以及排序,由操作系统决定,不同系统略有差异.
当函数被调用的时候, 一个新的栈帧被添加到栈的顶部. 当函数返回时,顶部的栈帧被移除.在执行过程中, 程序只能直接访问栈顶帧得数据(指针除外, 但是不建议如此设计).这种设计,方便了递归调用的实现, 因为每个子递归调用拥有独立的临时变量和参数备份.
下图介绍了栈的组织结构.(这只是示意图, 实际情况要根据 cpu设计来决定)&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>CFRunLoop examples</title>
      <link>http://ytlvy.com/posts/2015-06-30/2015-06-30-cfrunloop-examples/</link>
      <pubDate>Tue, 30 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-06-30/2015-06-30-cfrunloop-examples/</guid>
      <description>&lt;h3 id=&#34;第一个&#34;&gt;第一个&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;CoreFoundation/CoreFoundation.h&amp;gt;  
  
static void  
_perform(void *info __unused)  
{  
    printf(&amp;quot;hello\n&amp;quot;);  
}  
  
static void  
_timer(CFRunLoopTimerRef timer __unused, void *info)  
{  
    CFRunLoopSourceSignal(info);  
}  
  
int  
main()  
{  
    CFRunLoopSourceRef source;  
    CFRunLoopSourceContext source_context;  
    CFRunLoopTimerRef timer;  
    CFRunLoopTimerContext timer_context;  
  
    bzero(&amp;amp;source_context, sizeof(source_context));  
    source_context.perform = _perform;  
    source = CFRunLoopSourceCreate(NULL, 0, &amp;amp;source_context);  
    CFRunLoopAddSource(CFRunLoopGetCurrent(), source, kCFRunLoopCommonModes);  
  
    bzero(&amp;amp;timer_context, sizeof(timer_context));  
    timer_context.info = source;  
    timer = CFRunLoopTimerCreate(NULL, CFAbsoluteTimeGetCurrent(), 1, 0, 0, 
    _timer, &amp;amp;timer_context);  
    CFRunLoopAddTimer(CFRunLoopGetCurrent(), timer, kCFRunLoopCommonModes);  
  
    CFRunLoopRun();  
  
    return 0;  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Cancel a NSBlockOperation</title>
      <link>http://ytlvy.com/posts/2015-06-30/2015-06-30-cancel-a-nsblockoperation/</link>
      <pubDate>Tue, 30 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-06-30/2015-06-30-cancel-a-nsblockoperation/</guid>
      <description> make NSBlockOperation cancelable NSBlockOperation *operation = [[NSBlockOperation alloc] init]; __weak NSBlockOperation *weakOperation = operation; [operation addExecutionBlock:^{ while( ! [weakOperation isCancelled]){ //do something... } }];  </description>
    </item>
    
    <item>
      <title>Dispatch Sources</title>
      <link>http://ytlvy.com/posts/2015-06-30/2015-06-30-dispatch-sources/</link>
      <pubDate>Tue, 30 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-06-30/2015-06-30-dispatch-sources/</guid>
      <description>&lt;h2 id=&#34;dispatch-sources&#34;&gt;Dispatch Sources&lt;/h2&gt;

&lt;p&gt;简单来说，是一种能够监控某种事件的对象。当事件发生的时候，此对象自动唤醒设置好的block，并在指定的queue中运行。&lt;/p&gt;

&lt;h3 id=&#34;events-type&#34;&gt;events Type&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Mach port send right state changes.&lt;/li&gt;
&lt;li&gt;Mach port receive right state changes.&lt;/li&gt;
&lt;li&gt;External process state change.&lt;/li&gt;
&lt;li&gt;File descriptor ready for read.&lt;/li&gt;
&lt;li&gt;File descriptor ready for write.&lt;/li&gt;
&lt;li&gt;Filesystem node event.&lt;/li&gt;
&lt;li&gt;POSIX signal.&lt;/li&gt;
&lt;li&gt;Custom timer.&lt;/li&gt;
&lt;li&gt;Custom event.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;custom-events&#34;&gt;Custom Events&lt;/h3&gt;

&lt;p&gt;通过&lt;code&gt;dispatch_source_merge_data&lt;/code&gt;来发送消息，此方法取名&lt;code&gt;merge&lt;/code&gt;的原因是，在事件回调执行前，GCD会自动合并累计的消息，直到对应的运行Queue有空闲，可以运行回调Block。所以，这是一种提高效率的方式，将多次消息合并成一个。
自定义事件分为：&lt;code&gt;DISPATCH_SOURCE_TYPE_DATA_ADD&lt;/code&gt; 和 &lt;code&gt;DISPATCH_SOURCE_TYPE_DATA_OR&lt;/code&gt;, 每个event Source有一个&lt;code&gt;unsigned long data&lt;/code&gt;属性，用来合并&lt;code&gt;dispatch_source_merge_data&lt;/code&gt;的参数。&lt;code&gt;dispatch_source_get_data&lt;/code&gt;可以获取到当前的&lt;code&gt;data&lt;/code&gt;数据。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>DispatchOnce</title>
      <link>http://ytlvy.com/posts/2015-06-30/2015-06-30-dispatchonce/</link>
      <pubDate>Tue, 30 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-06-30/2015-06-30-dispatchonce/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;http://ytlvy.com/images/DispatchOnce.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;dispatch-once&#34;&gt;Dispatch_Once&lt;/h2&gt;

&lt;p&gt;四种场景如上图
1. 第一次执行，&lt;code&gt;block调用&lt;/code&gt;，调用结束后需要置标记变量
2. 非第一次执行，而此时#1&lt;code&gt;block调用&lt;/code&gt;尚未完成(预执行拿到的 obj 为 nil, 此时需要废弃此次预执行)，线程需进入等待#1状态
3. 非第一次执行，而此时#1&lt;code&gt;block调用&lt;/code&gt;已经完成(预执行拿到的 obj 已经初始化完毕)此时线程的预执行是正确的, 之后可能继续执行,也可能由于时间问题,废弃此次预执行进入等待
4. 非第一次执行，而此时#1已经完成，线程预执行后, 直接跳过block而进行后续任务&lt;/p&gt;

&lt;p&gt;Dispatch_Once 保证了当第一个线程在进行alloc 对象时，有其他线程发起, 会废弃此线程的预执行，进入等待。在第一个线程结束时，将正在等待的线程唤醒。而实现这一机制的方法是在生成对象和变更identifier之间加入一个大于预执行时间的等待来实现的。&lt;/p&gt;

&lt;h3 id=&#34;dispatch-once实现用到的技术&#34;&gt;Dispatch_Once实现用到的技术&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;原子操作 &amp;ldquo;原子比较交换函数&amp;rdquo; __sync_bool_compare_and_swap&lt;/li&gt;
&lt;li&gt;cpuid指令 实现大于预执行时间的延迟等待&lt;/li&gt;

&lt;li&gt;&lt;p&gt;dispatch_thread_semaphore 来实现线程之间的等待和唤醒
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Dispatch_semaphore</title>
      <link>http://ytlvy.com/posts/2015-06-30/2015-06-30-dispatch-semaphore/</link>
      <pubDate>Tue, 30 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-06-30/2015-06-30-dispatch-semaphore/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;http://ytlvy.com/images/DispatchSemaphore.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;dispatch-semaphore&#34;&gt;Dispatch_semaphore&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;semaphore&lt;/code&gt; 通过&lt;code&gt;dispatch_semaphore_create&lt;/code&gt;创建一个信号量来实现多线程并发数控制, 此信号量为最高可进行的并发数. 通过&lt;code&gt;dispatch_semaphore_wait&lt;/code&gt;来消耗一个信号量,并进入其后的执行逻辑, 在逻辑执行完毕后,通过&lt;code&gt;dispatch_semaphore_signal&lt;/code&gt;来释放一个信号量, 并唤醒正在等待的线程. 如果&lt;code&gt;dispatch_semaphore_wait&lt;/code&gt;操作时,信号量为0则进入等待状态.&lt;/p&gt;

&lt;h3 id=&#34;functions&#34;&gt;functions&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;dispatch_semaphore_create&lt;/li&gt;
&lt;li&gt;dispatch_semaphore_wait (减少一个信号量)&lt;/li&gt;
&lt;li&gt;dispatch_semaphore_signal (增加一个信号量)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;实例&#34;&gt;实例&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;- (void)test4{
    int data = 3;
    __block int mainData = 0;
    __block int sum = 0;
    __block dispatch_semaphore_t sem = dispatch_semaphore_create(2);
    dispatch_queue_t ioQueue = dispatch_queue_create(&amp;quot;com.dreamingwish.imagegcd.io&amp;quot;, DISPATCH_QUEUE_SERIAL);
    
    dispatch_queue_t queue = dispatch_queue_create(&amp;quot;StudyBlocks&amp;quot;, DISPATCH_QUEUE_CONCURRENT);
    dispatch_group_t group = dispatch_group_create();
    
    for (int i =0 ; i&amp;lt;100; i++) {
        @autoreleasepool {
            dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);  // -1 非零即通过
            dispatch_group_async(group, ioQueue, ^{
//                dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);
                dispatch_group_async(group, queue, ^{
                    sum += data;
                    
                    __block int nsum = sum;
                    dispatch_group_async(group, ioQueue, ^{
                        NSLog(@&amp;quot; &amp;gt;&amp;gt; Sum: %d&amp;quot;, nsum);
                        
                        dispatch_semaphore_signal(sem);  // +1
                    });
                    
                });
            });
        }
    }
    dispatch_group_wait(group, DISPATCH_TIME_FOREVER);
//    dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);
    for (int j =0; j&amp;lt;5; j++) {
        mainData++;
        NSLog(@&amp;quot; &amp;gt;&amp;gt; MainData: %d&amp;quot;, mainData);
    }
//    dispatch_semaphore_signal(sem);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>OSSpinLock</title>
      <link>http://ytlvy.com/posts/2015-06-30/2015-06-30-osspinlock/</link>
      <pubDate>Tue, 30 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-06-30/2015-06-30-osspinlock/</guid>
      <description>&lt;h2 id=&#34;osspinlock&#34;&gt;OSSpinLock&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;#import &amp;lt;Foundation/Foundation.h&amp;gt;
#import &amp;lt;objc/runtime.h&amp;gt;
#import &amp;lt;objc/message.h&amp;gt;
#import &amp;lt;libkern/OSAtomic.h&amp;gt;
#import &amp;lt;pthread.h&amp;gt;

#define ITERATIONS (1024*1024*32)

static unsigned long long disp=0, land=0;

int main(){
    double then, now;
    unsigned int i, count;
    pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
    OSSpinLock spinlock = OS_SPINLOCK_INIT;

    NSAutoreleasePool *pool = [NSAutoreleasePool new];

    NSLock *lock = [NSLock new];
    then = CFAbsoluteTimeGetCurrent();
    for(i=0; i&amp;lt;ITERATIONS; ++i)
    {
        [lock lock];
        [lock unlock];
    }
    now = CFAbsoluteTimeGetCurrent();
    printf(&amp;quot;NSLock: %f sec\n&amp;quot;, now-then);    

    then = CFAbsoluteTimeGetCurrent();
    IMP lockLock = [lock methodForSelector:@selector(lock)];
    IMP unlockLock = [lock methodForSelector:@selector(unlock)];
    
    for(i=0; i&amp;lt;ITERATIONS; ++i) {
        lockLock(lock,@selector(lock));
        unlockLock(lock,@selector(unlock));
    }
    now = CFAbsoluteTimeGetCurrent();
    printf(&amp;quot;NSLock+IMP Cache: %f sec\n&amp;quot;, now-then);    

    then = CFAbsoluteTimeGetCurrent();
    for(i=0;i&amp;lt;ITERATIONS;++i) {
        pthread_mutex_lock(&amp;amp;mutex);
        pthread_mutex_unlock(&amp;amp;mutex);
    }
    now = CFAbsoluteTimeGetCurrent();
    printf(&amp;quot;pthread_mutex: %f sec\n&amp;quot;, now-then);

    then = CFAbsoluteTimeGetCurrent();
    for(i=0; i&amp;lt;ITERATIONS; ++i) {
        OSSpinLockLock(&amp;amp;spinlock);
        OSSpinLockUnlock(&amp;amp;spinlock);
    }
    now = CFAbsoluteTimeGetCurrent();
    printf(&amp;quot;OSSpinlock: %f sec\n&amp;quot;, now-then);

    id obj = [NSObject new];

    then = CFAbsoluteTimeGetCurrent();
    for(i=0; i&amp;lt;ITERATIONS; ++i){
        @synchronized(obj) { }
    }
    now = CFAbsoluteTimeGetCurrent();
    printf(&amp;quot;@synchronized: %f sec\n&amp;quot;, now-then);

    [pool release];
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>UITableView Cancel Request</title>
      <link>http://ytlvy.com/posts/2015-06-30/2015-06-30-uitableview-cancel-request/</link>
      <pubDate>Tue, 30 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-06-30/2015-06-30-uitableview-cancel-request/</guid>
      <description>&lt;h3 id=&#34;仅加载可见cell的图片&#34;&gt;仅加载可见Cell的图片&lt;/h3&gt;

&lt;p&gt;load images for just the visible rows in viewDidLoad and when the user stops scrolling&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-(void)viewDidLoad{
    for (NSIndexPath *indexPath in [self.tableView indexPathsForVisibleRows]) {
        [self loadImageForCellAtPath:indexPath];
    }
}

-(void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView {
    for (NSIndexPath *indexPath in [self.tableView indexPathsForVisibleRows]) {
        [self loadImageForCellAtPath:indexPath];
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>ios MRC &amp;&amp; ARC</title>
      <link>http://ytlvy.com/posts/2015-06-16/2015-06-16-ios-mrc-arc/</link>
      <pubDate>Tue, 16 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-06-16/2015-06-16-ios-mrc-arc/</guid>
      <description>&lt;h2 id=&#34;arc&#34;&gt;ARC&lt;/h2&gt;

&lt;h3 id=&#34;mrc&#34;&gt;MRC&lt;/h3&gt;

&lt;h4 id=&#34;mrc内存管理原则&#34;&gt;MRC内存管理原则&lt;/h4&gt;

&lt;p&gt;􏰀1. You have ownership of any objects you create.
2.􏰀 You can take ownership of an object using retain.
􏰀3. When no longer needed, you must relinquish ownership of an object you own.
􏰀4. You must not relinquish ownership of an object you don’t own.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Action for Objective-C Object&lt;/th&gt;
&lt;th&gt;Objective-C Method&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Create and have ownership of it&lt;/td&gt;
&lt;td&gt;alloc/new/copy/mutableCopy group&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Take ownership of it&lt;/td&gt;
&lt;td&gt;retian&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Relinquish it&lt;/td&gt;
&lt;td&gt;release&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Dispose of it&lt;/td&gt;
&lt;td&gt;dealloc&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&#34;调用者持有&#34;&gt;调用者持有&lt;/h4&gt;

&lt;p&gt;Relinquishing Ownership of a Retained Object. 下面的例子将函数将自己持有的obj, 通过return传递给了调用者,由调用者来来持有此变量&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (id)allocObject
{
  /*
  - You create an object and have ownership. */
  id obj = [[NSObject alloc] init];
  /*
  - At this moment, this method has ownership of the object. */
  return obj; 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>ios block</title>
      <link>http://ytlvy.com/posts/2015-06-15/2015-06-15-ios-block/</link>
      <pubDate>Mon, 15 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-06-15/2015-06-15-ios-block/</guid>
      <description>&lt;h2 id=&#34;block&#34;&gt;Block&lt;/h2&gt;

&lt;p&gt;Converting Source Code&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;clang -rewrite-objc file_name_of_the_source_code
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;无变量&#34;&gt;无变量&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;//
struct __block_impl {
  void *isa;
  int Flags;
  int Reserved;
  void *FuncPtr;
};

struct __main_block_impl_0 {
  struct __block_impl impl;
  struct __main_block_desc_0* Desc;
  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) {
    impl.isa = &amp;amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};
static void __main_block_func_0(struct __main_block_impl_0 *__cself) {

    printf(&amp;quot;Block\n&amp;quot;);
  }

static struct __main_block_desc_0 {
  size_t reserved;
  size_t Block_size;
} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};

int main(){
  void (*blk)(void) = (void (*)())&amp;amp;__main_block_impl_0((void *)__main_block_func_0, &amp;amp;__main_block_desc_0_DATA);

  ((void (*)(__block_impl *))((__block_impl *)blk)-&amp;gt;FuncPtr)((__block_impl *)blk);
  return 0;

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>ios gcd</title>
      <link>http://ytlvy.com/posts/2015-06-15/2015-06-15-ios-gcd/</link>
      <pubDate>Mon, 15 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-06-15/2015-06-15-ios-gcd/</guid>
      <description>&lt;h2 id=&#34;gcd&#34;&gt;GCD&lt;/h2&gt;

&lt;h3 id=&#34;befor-gcd&#34;&gt;befor GCD&lt;/h3&gt;

&lt;h4 id=&#34;object-method&#34;&gt;object method&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;- (void) performSelectorInBackground: withObject:
- (void) performSelectorOnMainThread: withObject: waitUntilDone:
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;多线程面临的问题&#34;&gt;多线程面临的问题&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;race condition&lt;/li&gt;
&lt;li&gt;dead lock&lt;/li&gt;
&lt;li&gt;too much threads consumes two much memory&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;多线程的意义&#34;&gt;多线程的意义&lt;/h4&gt;

&lt;p&gt;高交互性， 界面编程中，将耗时的操作放入到其他线程执行，避免影响到主线程界面响应&lt;/p&gt;

&lt;h3 id=&#34;gcd-基础&#34;&gt;GCD 基础&lt;/h3&gt;

&lt;h4 id=&#34;dispatch-queue-派发队列&#34;&gt;Dispatch Queue 派发队列&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;serial dispath queue  顺序派发队列&lt;/li&gt;
&lt;li&gt;concurrent dispath queue  并发派发队列&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;和浏览器对同一域名可发起的同时连接数限制一样，可最多同时执行的线程数，也是由系统来决定的
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>AutoLayout -- Content Compression Resistance &amp; Content Hugging</title>
      <link>http://ytlvy.com/posts/2015-06-08/2015-06-08-autolayout-content-compression-resistance-content-hugging/</link>
      <pubDate>Mon, 08 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-06-08/2015-06-08-autolayout-content-compression-resistance-content-hugging/</guid>
      <description>&lt;h2 id=&#34;content-compression-resistance-content-hugging&#34;&gt;Content Compression Resistance &amp;amp;&amp;amp; Content Hugging&lt;/h2&gt;

&lt;p&gt;Auto Layout中, 存在Content Compression Resistance 和 Content Hugging 这两个概念.这两个概念是在&lt;code&gt;固有内容尺寸&lt;/code&gt;（Intrinsic Content Size）之上起作用的.&lt;/p&gt;

&lt;h3 id=&#34;intrinsic-content-size&#34;&gt;Intrinsic Content Size&lt;/h3&gt;

&lt;p&gt;包含内容的UI控件, 由内容多少而决定的大小规则.&lt;/p&gt;

&lt;h3 id=&#34;content-compression-resistance-content-hugging-1&#34;&gt;Content Compression Resistance &amp;amp; Content Hugging&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;内容大小改变是指, 内容显示内容所占空间的长度来说的.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;内容抗压指数&lt;/code&gt;，在父视图变小时, 会根据抗压指数来缩小各子控件;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;内容拥抱指数&lt;/code&gt;, 内容越集中于控件中心, 周围空白越小.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>objc runtime method Cache</title>
      <link>http://ytlvy.com/posts/2015-06-08/2015-06-08-objc-runtime-method-cache/</link>
      <pubDate>Mon, 08 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-06-08/2015-06-08-objc-runtime-method-cache/</guid>
      <description> method cache 更新机制 为了方便函数的查找, objc在运行时,引入了method cache机制,来快速定位函数.method cache的大小是动态更新的,在更新时, 将直接生成新容量的缓存, 并将旧的缓存放入到垃圾队列中,等待时机释放. 而时机的选择, 采用检测每个线程的program counter,来查看是否处于objc_msgSend.如果都不在,则释放.
BOOL ThreadsInMsgSend(void) { for(thread in GetAllThreads()) { uintptr_t pc = thread.GetPC(); if(pc &amp;gt;= objc_msgSend_startAddress &amp;amp;&amp;amp; pc &amp;lt;= objc_msgSend_endAddress) { return YES; } } return NO; } bucket_t *oldCache = class-&amp;gt;cache; class-&amp;gt;cache = malloc(newSize); append(gOldCachesList, oldCache); if(!ThreadsInMsgSend()) { for(cache in gOldCachesList) { free(cache); } gOldCachesList.clear(); }  </description>
    </item>
    
    <item>
      <title>IOS Multithreading &amp;&amp; Memory Management</title>
      <link>http://ytlvy.com/posts/2015-06-07/2015-06-07-ios-multithreading-memory-management/</link>
      <pubDate>Sun, 07 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ytlvy.com/posts/2015-06-07/2015-06-07-ios-multithreading-memory-management/</guid>
      <description>&lt;h2 id=&#34;block&#34;&gt;Block&lt;/h2&gt;

&lt;p&gt;Converting Source Code&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;clang -rewrite-objc file_name_of_the_source_code
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;无变量&#34;&gt;无变量&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;//
struct __block_impl {
  void *isa;
  int Flags;
  int Reserved;
  void *FuncPtr;
};

struct __main_block_impl_0 {
  struct __block_impl impl;
  struct __main_block_desc_0* Desc;
  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) {
    impl.isa = &amp;amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};
static void __main_block_func_0(struct __main_block_impl_0 *__cself) {

    printf(&amp;quot;Block\n&amp;quot;);
  }

static struct __main_block_desc_0 {
  size_t reserved;
  size_t Block_size;
} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};

int main(){
  void (*blk)(void) = (void (*)())&amp;amp;__main_block_impl_0((void *)__main_block_func_0, &amp;amp;__main_block_desc_0_DATA);

  ((void (*)(__block_impl *))((__block_impl *)blk)-&amp;gt;FuncPtr)((__block_impl *)blk);
  return 0;

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>